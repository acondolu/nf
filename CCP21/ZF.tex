%!TEX root = main.tex

Let us start by summarizing the classic encoding of \ZF{} in Coq by Benjamin Werner \cite{DBLP:conf/tacs/Werner97}\footnotemark{}, which \TODO{as already mention Aczel.}

\footnotetext{The source code of the encoding of \ZF{} is included in the repository of Coq users' contributions, and can be found at the address \url{https://github.com/coq-contribs/zfc/}.}

The steps are the following:
\begin{itemize}
  \item \emph{Type of sets:} defined \coqdocinductive{SET}\footnotemark{}
  \item \emph{(Extensional) equality:} define \coqdocdefinition{EQ}. setoid, etc.
  \item \emph{Set membership:} define \coqdocdefinition{IN} morphism
  \item \emph{Axiom of extensionality}
  \item \emph{Remaining axiom / set operators} and their properties
\end{itemize}

\footnotetext{We use the uppercase identifiers \coqdocinductive{SET}, \coqdocdefinition{EQ}, and \coqdocdefinition{IN} in order to avoid shadowing, respectively, the kind \coqdocdefinition{Set}, the standard (intensional) equality \coqdocdefinition{eq}, and the reserved keyword \coqdockw{in}.}

\subsection{The Type \texorpdfstring{\coqdocinductive{SET}}{SET}}
The type representing sets

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdocinductive{SET} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{2.00em}
\coqdocconstructor{Sup} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, (\coqdocvar{X} \ensuremath{\rightarrow} \coqdocinductive{SET}) \ensuremath{\rightarrow} \coqdocinductive{SET}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\TODO{index type $X$ plus an indexing function}

\noindent\paragraph{Notation.} From now on, we will use the variables \var s and \var t to denote elements of type \coqdocinductive{SET}. We reserve the variable names \var x, \var y, \var z for elements of types \var X, \var Y, \var Z respectively.

\begin{example}[Empty set]aaa

  \begin{coqdoccode}
    \coqdocnoindent
    \coqdockw{Definition} \coqdocdefinition{Ø} := \coqdocconstructor{Sup} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} (\coqdockw{fun} \coqdocvar{k} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{k} \coqdockw{with} \coqdockw{end}).\coqdoceol
    \coqdocemptyline
  \end{coqdoccode}
  \TODO{False is just a type with no inhabitants, explain empty pattern matching, dire anche \coqexternalref{False rect}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{False\_rect}} \coqdocvar{\_}}
\end{example}

\begin{example}[Set union]
  Index type is the disjoint union of the indexes, and the indexing is the sum of the indexings:
  \begin{coqdoccode}
    \coqdocemptyline
    \coqdocnoindent
    \coqdockw{Definition} \coqdocdefinition{union} \coqdocvar{s} \coqdocvar{s'} := \coqdockw{match} \coqdocvar{s}, \coqdocvar{s'} \coqdockw{with}\coqdoceol
    \coqdocindent{1.00em}
    \coqdocconstructor{Sup} \coqdocvar{X} \coqdocvar{f}, \coqdocconstructor{Sup} \coqdocvar{Y} \coqdocvar{g} \ensuremath{\Rightarrow} \coqdocvar{Sup} (\coqdocvar{X} + \coqdocvar{Y}) (\coqdocvar{f} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvar{g})\coqdoceol
    \coqdocnoindent
    \coqdockw{end}.\coqdoceol
  \end{coqdoccode}

  \TODO{+ is the disjoint sum (union) of types, and ⨁ is the sum of functions, defined as follows:}

  \begin{coqdoccode}
    \coqdocnoindent
    \coqdockw{Definition} \coqdefRef{Internal.Misc.sumF}{sumF}{\coqdocdefinition{sumF}} \{\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z}\} \coqdoceol
    \coqdocindent{1.00em}: \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X} \coqexternalref{::type scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{+}} \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z} \coqdoceol
    \coqdocindent{1.00em} := \coqdockw{fun} \coqdocvar{f} \coqdocvar{g} \coqdocvar{xy} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{xy} \coqdockw{with}\coqdoceol
    \coqdocindent{8.00em}
    \ensuremath{|} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvariable{f} \coqdocvar{x}\coqdoceol
    \coqdocindent{8.00em}
    \ensuremath{|} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdocvariable{g} \coqdocvar{y}\coqdoceol
    \coqdocindent{8.00em}
    \coqdockw{end}.\coqdoceol
    \coqdocnoindent
    \coqdockw{Infix} \coqdef{Internal.Misc.:::x 'xE2xA8x81' x}{"}{"}⨁" := \coqref{Internal.Misc.sumF}{\coqdocdefinition{sumF}} (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
    \coqdocemptyline
    \end{coqdoccode}
\end{example}

\subsection{Set Equality}

Recursive Definition of the extentional equality on sets

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Fixpoint} \coqdocdefinition{EQ} \coqdocvar{s} \coqdocvar{t} : \coqdockw{Prop} :=\coqdoceol
  \coqdocindent{1.00em}
  \coqdockw{match} \coqdocvar{s}, \coqdocvar{t} \coqdockw{with}\coqdoceol
  \coqdocindent{1.00em}
  \ensuremath{|} \coqdocconstructor{Sup} \coqdocvar{X} \coqdocvar{f}, \coqdocconstructor{Sup} \coqdocvar{Y} \coqdocvar{g} \ensuremath{\Rightarrow}\coqdoceol
  \coqdocindent{2.00em}
  (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdoctac{\ensuremath{\exists}} \coqdocvar{y}, \coqdocvar{EQ} (\coqdocvar{f} \coqdocvar{x}) (\coqdocvar{g} \coqdocvar{y})) \ensuremath{\land} (\coqdockw{\ensuremath{\forall}} \coqdocvar{y}, \coqdoctac{\ensuremath{\exists}} \coqdocvar{x}, \coqdocvar{EQ} (\coqdocvar{f} \coqdocvar{x}) (\coqdocvar{g} \coqdocvar{y}))\coqdoceol
  \coqdocindent{1.00em}
  \coqdockw{end}.\coqdoceol
  \coqdocnoindent
\coqdockw{Infix} ``≡'' := \coqref{NF2.Model.EQ}{\coqdocdefinition{EQ}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\TODO{parlare di Coq fixpoint}

Aczel's equality


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdefRef{Internal.Misc.eq aczel}{eq\_aczel}{\coqdocdefinition{eq\_aczel}} \{\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z}\} (\coqdocvar{R}: \coqdocvariable{Z} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) \coqdocvar{f} \coqdocvar{g} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}: \coqdocvariable{X}, \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{y}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{R} (\coqdocvariable{f} \coqdocvariable{x}) (\coqdocvariable{g} \coqdocvariable{y})\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{y}: \coqdocvariable{Y}, \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{R} (\coqdocvariable{f} \coqdocvariable{x}) (\coqdocvariable{g} \coqdocvariable{y}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\coqdocconstructor{Sup} \coqdocvar{X} \coqdocvar{f} $\equiv$ \coqdocconstructor{Sup} \coqdocvar{Y} \coqdocvar{g} $~\Leftrightarrow$ \coqdocdefinition{eq\_aczel} \coqdocvar{EQ} \coqdocvar{f} \coqdocvar{g}

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Infix} ``\ensuremath{\AEQ}'' := (\coqdocdefinition{eq\_aczel} \coqdocvar{EQ}).\coqdoceol
\end{coqdoccode}

\coqdocconstructor{Sup} \coqdocvar{X} \coqdocvar{f} $\equiv$ \coqdocconstructor{Sup} \coqdocvar{Y} \coqdocvar{g} $~\Leftrightarrow$ \coqdocvar{f} $\AEQ$ \coqdocvar{g}

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Instance} \coqdocinstance{zfc\_setoid} : \coqexternalref{Equivalence}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Classes.RelationClasses}{\coqdocclass{Equivalence}} \coqdocdefinition{EQ}.
\end{coqdoccode}
\begin{proof}
  All required statements (reflexivity, symmetry, and transitivity) are proven easily by structural induction on the first quantified variable.
\end{proof}

\subsection{Set Membership}

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Definition} \coqdocdefinition{IN} \coqdocvar{s} \coqdocvar{t} : \coqdockw{Prop} :=
\coqdockw{match} \coqdocvar{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocconstructor{Sup} \coqdocvar{X} \coqdocvar{f} \ensuremath{\Rightarrow} \coqdoctac{\ensuremath{\exists}} \coqdocvar{x}, \coqdocvar{EQ} \coqdocvar{s} (\coqdocvar{f} \coqdocvar{x})\coqdoceol
\coqdocindent{0.00em}\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Infix} ``∈'' := \coqdocdefinition{IN}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Definition} \coqdefRef{Internal.Common.in aczel}{in\_aczel}{\coqdocdefinition{in\_aczel}} \{\coqdocvar{X} \coqdocvar{Z}\} (\coqdocvar{R}: \coqdocvariable{Z} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) \coqdocvar{s} \coqdocvar{f} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x}: \coqdocvariable{X}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{R} (\coqdocvariable{f} \coqdocvariable{x}) \coqdocvariable{s}.\coqdoceol
\coqdocindent{0.00em}
\coqdockw{Infix} ``\AIN'' := (\coqdocdefinition{in\_aczel} \coqdocdefinition{IN}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}

So that:

s $\in$ \coqdocconstructor{Sup} \coqdocvar{X} \coqdocvar{f} $~\Leftrightarrow$ \coqdocvar{s} $\AIN$ \coqdocvar{f}

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Add} \coqdockw{Morphism} \coqref{NF2.Model.IN}{\coqdocdefinition{IN}} \coqdockw{with} \coqdockw{signature} \coqref{NF2.Model.EQ}{\coqdocdefinition{EQ}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{$\Rightarrow$}} \coqref{NF2.Model.EQ}{\coqdocdefinition{EQ}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{$\Rightarrow$}} \coqexternalref{iff}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{iff}} \coqdockw{as} \coqdefRef{NF2.Model.IN mor}{IN\_mor}{\coqdocinstance{IN\_mor}}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  Proved using two intermediate lemmas (both relying on transitivity of \coqdocdefinition{EQ}):
  \begin{itemize}
    \item \coqdocdefinition{IN\_sound\_right}: %
    \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{s'} \coqdocvar{t} : \coqdocdefinition{SET}, \coqdocvar{s} \EQ \coqdocvar{s'} \ensuremath{\rightarrow} \coqdocvar{t} \IN \coqdocvar{s} \ensuremath{\rightarrow} \coqdocvar{t} \IN \coqdocvar{s'}.


    Proof. Let $\var s = \coqdocconstructor{Sup}~\var X~\var f$ and $\var t = \coqdocconstructor{Sup}~\var Y~\var g$ by destruction. Assume $\var s \equiv \var{s'}$ and $\var t \in \var s$; we need to show that $\var t \in \var{s'}$. From $\var t \in \var s$ it follows that there exists $\var x\colon \var X$ such that $\var t \equiv \var f~\var x$. From the left conjunct in the unfolding of $\var s \equiv \var t$, we obtain a $\var y\colon \var Y$ such that $\var f~\var x \equiv \var g~\var y$. By transitivity of $\equiv$, it follows that $\var t \equiv \var g~\var y$, and we thus conclude with $\var t \in \var{s'}$.


    \item \coqdocdefinition{IN\_sound\_left}: %
    \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{s'} \coqdocvar{t} : \coqdocdefinition{SET}, \coqdocvar{s} \EQ \coqdocvar{s'} \ensuremath{\rightarrow} \coqdocvar{s} \IN \coqdocvar{t} \ensuremath{\rightarrow} \coqdocvar{s'} \IN \coqdocvar{t}. Similarly immediate proof.
    \qedhere
  \end{itemize}
\end{proof}

\subsection{Extensionality}
\TODO{}


\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Theorem} \coqdoclemma{ext}: \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{s'}, \coqdocvariable{s} \coqdocnotation{≡} \coqdocvariable{s'} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvariable{t} \coqdocnotation{∈} \coqdocvariable{s} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \coqdocnotation{∈} \coqdocvariable{s'}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  Let $\var s = \coqdocconstructor{Sup}~\var X~\var f$ and $\var t = \coqdocconstructor{Sup}~\var Y~\var g$ by destruction.
  We prove the two directions of the double implication separately:
  \begin{itemize}
    \item[$(\Rightarrow)$] Follows directly from \coqdocdefinition{IN\_sound\_right} proved in the previous section.

    \item[$(\Leftarrow)$] Let's assume $\forall \var t, \var t\in \var s \leftrightarrow \var t \in \var{s'}$ to prove $\var s \equiv \var t$. Without loss of generality, we prove only the first conjunct in the unfolding of $\var s \equiv \var {s'}$, \ie{} $\forall \var x, \exists \var y, \var f~\var x \equiv \var g~\var y$. Assume $\var x\colon \var X$: it follows from the hypothesis that $\var f~\var x\in \var s \leftrightarrow \var f~\var x \in \var{s'}$. It is easy to see that $\var f~\var x\in \var s$ holds, hence it follows that $\var f~\var x \in \var{s'}$ as well, \ie{} there exists $\var y$ such that $\var f~\var x \equiv \var g~\var y$.
    \qedhere
  \end{itemize}
\end{proof}

\subsection{Other \ZF{} Axioms}
\TODO{}
