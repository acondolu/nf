%!TEX root = main.tex

To prove extensionality for \NFO{} we follow a strategy similar to the one used for \NFTWO{}, but quite more involved. As usual, one of the directions of the double implication follows from \coqdocdefinition{in\_sound\_right}; the other direction is non-trivial. The idea is similar to the \NFTWO{} case: obtain a contradiction when a low set has the same extension of a high set. However here there is no clear syntactical difference between low sets and high sets, thus a more refined argument is required.

A fundamental lemma is again\coqdoclemma{weak\_regularity}:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdefRef{NFO.Ext.weak regularity}{weak\_regularity}{\coqdoclemma{weak\_regularity}} \coqdocvar{s} :\coqdoceol
  \coqdocindent{1.00em}
  \coqdockw{match} \coqdocvariable{s} \coqdockw{with} \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f} \coqdocvar{\_} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvariable{s} \AIN \coqdocvar{f} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} \coqdockw{end}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  By induction on the structure of \coqdocvar{s}.
\end{proof}

% \TODO{The problem: let $A \XOR B$ and $A' \XOR B'$ two \NFO{} sets. } It is not too difficult to prove extensionality separately for A-parts and B-parts of sets:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Theorem} \coqdefRef{NFO.Morphism.Aext}{Aext}{\coqdoclemma{Aext}} \coqdocvar{X} \coqdocvar{Y} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvar{\_}) (\coqdocvar{f'}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvar{\_}) :\coqdoceol
\coqdocindent{1.00em} \coqdocvariable{f} \AEQ \coqdocvariable{f'} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqdocvariable{s} \AIN \coqdocvariable{f} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s} \AIN \coqdocvariable{f'}.\coqdoceol
\end{coqdoccode}


\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Theorem} \coqdefRef{NFO.Morphism.Bext}{Bext}{\coqdoclemma{Bext}} \coqdocvar{X} \coqdocvar{Y} (\coqdocvar{g}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvar{\_}) (\coqdocvar{g'}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvar{\_}) \coqdocvar{e} \coqdocvar{e'} :\coqdoceol
\coqdocindent{1.00em}
\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e} \BEQ \coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g'} \coqdocvariable{e'}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqdocvariable{s} \BIN \coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s} \BIN \coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g'} \coqdocvariable{e'}.\coqdoceol
\end{coqdoccode}

 Set with empty extension:
 
 \begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Definition} \coqdef{NFO.Ext.ext empty}{ext\_empty}{\coqdocdefinition{ext\_empty}} \coqdocvar{s} := \coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{NFO.In.IN}{\coqdocdefinition{IN}} \coqdocvariable{t} \coqdocvariable{s}.\coqdoceol
  \coqdocemptyline
\end{coqdoccode}

  Two sets have the same extension iff their simmetric difference has empty extension:

  \begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdefRef{NFO.Ext.xor ext}{xor\_ext}{\coqdoclemma{xor\_ext}}: \coqdockw{\ensuremath{\forall}} \{\coqdocvar{s} \coqdocvar{s'}\},\coqdoceol
  \coqdocindent{1.00em}
  \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvariable{t} \INX \coqdocvariable{s} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \INX \coqdocvariable{s'}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{NFO.Ext.ext empty}{\coqdocdefinition{ext\_empty}} (\coqdocvariable{s} \SXOR \coqdocvariable{s'}).\coqdoceol
  \end{coqdoccode}

Then, the symmetric difference of two sets is the empty set iff the two sets are equivalent:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Theorem} \coqdefRef{NFO.Sets.xor empty}{xor\_empty}{\coqdoclemma{xor\_empty}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{s'}, \coqref{NFO.Eq.::type scope:x '==' x}{\coqdocnotation{(}}\coqdocvariable{s}  \SXOR \coqdocvariable{s'}\coqref{NFO.Eq.::type scope:x '==' x}{\coqdocnotation{)}} \EQX \coqref{NFO.Sets.emptyset}{\coqdocdefinition{emptyset}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \EQX \coqdocvariable{s'}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  Follows from the definition of \XORS{} and by lemmas \coqref{NFO.Morphism.Aext}{\coqdoclemma{Aext}} and \coqref{NFO.Morphism.Bext}{\coqdoclemma{Bext}}
\end{proof}

It remains to prove is that \coqref{NFO.Ext.ext empty}{\coqdocdefinition{ext\_empty}} \coqdocvariable{s} implies \coqdocvariable{s} \EQX \coqref{NFO.Sets.emptyset}{\coqdocdefinition{emptyset}} (which will only be proved in \coqref{NFO.Ext.no urelements}{\coqdoclemma{no\_urelements}} at the end of the section).
%  The difficulty is the following:

  % TODO: define ``urelement'' in the article (a set where the A-part has the same extension as the B-part, i.e. it's extensionally empty, but it's different from the empty set, i.e. has non-empty (and with same extension) parts )


  

\paragraph{Sloppy membership.}
B-sets have a peculiar property which makes us call them \emph{sloppy}: unlike A-sets, a B-set cannot be required to contain exactly some precise, specified elements. By construction, the boolean expression defining a B-set states whether the elements of the B-set should or should not contain the sets in the codomain of the indexing g; a bexpr however does not mention any set outside of the codomain of g.

We call informally \coqdocvar{g}-\emph{signature} of a set \coqdocvar{s} (with respect to an indexing \coqdocvar{g}) the sets in the image of \coqdocvar{g} which are also elements of \coqdocvar{s}. The signature is a fundamental concept concerning B-sets: a B-set defined by an indexing \coqdocvar{g} and a bexrp \var{e} cannot distinguish between sets having the same \coqdocvar{g}-\emph{signature}. In other words, when a B-set contains a set of a given signature, then it must contain all sets having the same signature.

This property is formalized in the following lemma:
   
\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdefRef{NFO.Ext.sloppy Bext}{sloppy\_Bext}{\coqdoclemma{sloppy\_Bext}} \{\coqdocvar{Y}\} (\coqdocvar{g}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}) \coqdocvar{s} \coqdocvar{s'} \coqdocvar{e}:\coqdoceol
  \coqdocindent{1.00em}
  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{y}, (\coqdocvariable{g} \coqdocvariable{y}) \INX \coqdocvariable{s} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}}  (\coqdocvariable{g} \coqdocvariable{y}) \INX \coqdocvariable{s'}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqdoceol
  \coqdocindent{2.00em}
  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}  \coqdocvariable{s} \BIN(\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s'} \BIN (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e}).\coqdoceol
\end{coqdoccode}
\begin{proof}
  By induction on the structure of \coqdocvariable{e}.
\end{proof}

% \TODO{If we assuming the existence of urelements, then \dots and we are in the case where the A-part has the same extension of the B-part. Which is contradictory. Let us assume by contradiction. }

In case a A-set has the same extension of a B-set, the A-set satisfies a property corresponding to \coqref{NFO.Ext.sloppy Bext}{\coqdoclemma{sloppy\_Bext}}: it cannot distinguish between sets having the same \coqdocvar{g}-signature.

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdefRef{NFO.Ext.sloppy Aext}{sloppy\_Aext}{\coqdoclemma{sloppy\_Aext}} \{\coqdocvar{X} \coqdocvar{Y}\} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}) (\coqdocvar{g}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}) \coqdocvar{s} \coqdocvar{s'} \coqdocvar{e}:\coqdoceol
  \coqdocindent{1.00em}
  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvariable{t} \AIN \coqdocvariable{f} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \BIN (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqdoceol
  \coqdocindent{1.00em}
  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{y}, (\coqdocvariable{g} \coqdocvariable{y}) \INX \coqdocvariable{s} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} (\coqdocvariable{g} \coqdocvariable{y}) \INX \coqdocvariable{s'}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqdoceol
  \coqdocindent{1.00em}
  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}  \coqdocvariable{s} \AIN \coqdocvariable{f} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s'} \AIN \coqdocvariable{f}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  By \coqref{NFO.Ext.sloppy Bext}{\coqdoclemma{sloppy\_Bext}}.
\end{proof}

Like for \NFTWO, we can construct a universal low set, \ie{} a universal \A-set in this case:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Definition} \coqdefRef{NFO.Ext.X univ}{X\_univ}{\coqdocdefinition{X\_univ}} \{\coqdocvar{Y}\} \coqdocvar{X} (\coqdocvar{g}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}) :=\coqdoceol
  \coqdocindent{1.00em}
  \coqexternalref{prod}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{prod}} \coqdocvariable{X} \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\{}} \sig{} \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\&}} \coqref{Internal.FunExt.respects}{\coqdocdefinition{respects}} (\coqref{NFO.Eq.EQ}{\coqdocdefinition{EQ}} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{⨀}} \coqdocvariable{g}) \sig{} \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\}}}.\coqdoceol
  \coqdocemptyline
  \coqdocnoindent
  \coqdockw{Definition} \coqdefRef{NFO.Ext.f univ}{f\_univ}{\coqdocdefinition{f\_univ}} \{\coqdocvar{X} \coqdocvar{Y}\} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}) (\coqdocvar{g}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}})\coqdoceol
  \coqdocindent{1.00em}
  : \coqref{NFO.Ext.X univ}{\coqdocdefinition{X\_univ}} \coqdocvariable{X} \coqdocvariable{g} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}} :=\coqdoceol
  \coqdocindent{1.00em}
  \coqdockw{fun} \coqdocvar{xu} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{xu} \coqdockw{with} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqexternalref{existT}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} \sig{} \coqdocvar{\_}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \ensuremath{\Rightarrow}\coqdoceol
  \coqdocindent{2.00em}
  \coqdockw{match} \coqdocvariable{f} \coqdocvar{x} \coqdockw{with}\coqdoceol
  \coqdocindent{2.00em}
  \ensuremath{|} \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f'} \coqdocvar{g'} \coqdocvar{e'} \ensuremath{\Rightarrow}  \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{\_} \coqdocvar{\_} (\coqdocvar{f'} \AXOR \coqref{Internal.Misc.select}{\coqdocdefinition{select}} \coqdocvariable{g} \sig{}) \coqdocvar{g'} \coqdocvar{e'}\coqdoceol
  \coqdocindent{2.00em}
  \coqdockw{end}\coqdoceol
  \coqdocindent{1.00em}
  \coqdockw{end}.\coqdoceol
  \coqdocemptyline
\end{coqdoccode}

The fundamental result is:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdefRef{NFO.Ext.universal low}{universal\_low}{\coqdoclemma{universal\_low}} \{\coqdocvar{X} \coqdocvar{Y}\} \{\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}\} (\coqdocvar{g}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}) \coqdocvar{e}:\coqdoceol
  \coqdocindent{1.00em}
  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqdocvariable{s} \AIN \coqdocvariable{f} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s} \BIN (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqdoceol
  \coqdocindent{1.00em}
  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{s} \AIN \coqdocvariable{f}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqdoceol
  \coqdocindent{1.00em}
  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqdocvariable{s} \AIN (\coqref{NFO.Ext.f univ}{\coqdocdefinition{f\_univ}} \coqdocvariable{f} \coqdocvariable{g}).\coqdoceol
\end{coqdoccode}
\begin{proof}
  % \TODO{ IMPORTANT! }
% 
  Let us assume a set \var t such that \var t \AIN \coqdocvariable{f}, and let \var s = \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f'} \coqdocvar{g'} \coqdocvar{e'} be any set.
% 
  % By the first hypothesis, it follows that \var t \BIN \coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e}.

  
  To show that \coqdocvariable{s} \AIN (\coqref{NFO.Ext.f univ}{\coqdocdefinition{f\_univ}} \coqdocvariable{f} \coqdocvariable{g}), we need to provide an index \var u: \coqref{NFO.Ext.X univ}{\coqdocdefinition{X\_univ}} \var X \var Y such that \var s \EQX \coqref{NFO.Ext.f univ}{\coqdocdefinition{f\_univ}} \var f \var g \var u. The index \var u should be a \var x: \var X together with a \var g-signature $\sigma$: then, it must hold \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f'} \coqdocvar{g'} \coqdocvar{e'} \EQX \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{\_} \coqdocvar{\_} (\coqdocvar{f'} \AXOR \coqref{Internal.Misc.select}{\coqdocdefinition{select}} \coqdocvariable{g} \sig{}) \coqdocvar{g'} \coqdocvar{e'}

  \newcommand\stilde{\var{$\tilde s$}}
  Let \sig s be the \var g-signature of \var s and \sig t be the \var g-signature of \var t.

  The idea is to alter the signature of \var s, obtaining a variant \stilde{} of \var s that belongs to the image of \var f. We obtain \stilde{} by simply applying to \var s the signature \sig s \XORP \sig t, the xor of the two signatures: in this way, \stilde{} has the same \var g-signature of \var t, and thus \AIN \var f (by \coqref{NFO.Ext.sloppy Aext}{\coqdoclemma{sloppy\_Aext}}). 

  % pose (S _ _ (AXor f0 (select g sig_xor)) g0 e0) as s_signed.
  % cut (forall y, IN (g y) t <-> IN (g y) s_signed). intro H1.
\end{proof}

% \TODO{define \XORP}

% a

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdefRef{NFO.Ext.not IN not AIN}{not\_IN\_not\_AIN}{\coqdoclemma{not\_IN\_not\_AIN}} \{\coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{e}\}:\coqdoceol
  \coqdocindent{1.00em}
  \coqref{NFO.Ext.ext empty}{\coqdocdefinition{ext\_empty}} (\coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvariable{X} \coqdocvariable{Y} \coqdocvariable{f} \coqdocvariable{g} \coqdocvariable{e}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}  \coqdocvariable{s} \AIN \coqdocvariable{f}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  By \coqref{NFO.Ext.weak regularity}{\coqdoclemma{weak\_regularity}} and \coqref{NFO.Ext.universal low}{\coqdoclemma{universal\_low}}.
\end{proof}

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdefRef{NFO.Ext.no urelements}{no\_urelements}{\coqdoclemma{no\_urelements}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqref{NFO.Ext.ext empty}{\coqdocdefinition{ext\_empty}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \EQX \coqref{NFO.Sets.emptyset}{\coqdocdefinition{emptyset}}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  By \coqref{NFO.Ext.not IN not AIN}{\coqdoclemma{not\_IN\_not\_AIN}} it follows that the A-part of \var s has empty extension; this, combined with the hypothesis that \var s has empty extension, easily implies that also the B-part of \var s must have empty extension. To conclude, just use \coqref{NFO.Morphism.Aext}{\coqdoclemma{Aext}} and \coqref{NFO.Morphism.Bext}{\coqdoclemma{Bext}}.
\end{proof}

  We can finally prove extensionality of NFO sets:

  \begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Theorem} \coqdefRef{NFO.Ext.ext}{ext}{\coqdoclemma{ext}}:\coqdoceol
  \coqdocindent{1.00em}
  \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{s'}, \coqdocvariable{s} \EQX \coqdocvariable{s'} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvariable{t} \INX \coqdocvariable{s} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \INX \coqdocvariable{s'}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  Follows directly from lemmas 
  \coqref{NFO.Ext.xor ext}{\coqdoclemma{xor\_ext}},
  \coqref{NFO.Ext.no urelements}{\coqdoclemma{no\_urelements}}, and
  \coqref{NFO.Sets.xor empty}{\coqdoclemma{xor\_empty}}.
\end{proof}
