%!TEX root = main.tex

\renewcommand\INX{\coqref{NF2.Model.IN}{{\IN}}~}
\renewcommand\EQX{\coqref{NF2.Model.EQ}{{\EQ}}~}

\NFTWO{} is the sub-theory of \NF{} characterized by the axiom of extensionality plus universe ($\Universe$), complement ($\Complement \Placeholder$), union ($\Union \Placeholder \Placeholder$), and singleton ($\Sing\Placeholder$) and their related axioms.

% $\Universe, \Complement \Placeholder, \Union \Placeholder \Placeholder, \Sing\Placeholder, \Essence\Placeholder$

\medskip

A first attempt at constructing a model for \NFTWO{} could be to take the \emph{free algebra} generated by these set constructors, basically identifying sets with free expressions of sets. Unfortunately, this approach is bound to fail:

\begin{itemize}
  \item 
  When defining the membership relation \coqdocdefinition{IN}, the singleton constructor $\Sing\Placeholder$ forces \coqdocdefinition{IN} to depend on \coqdocdefinition{EQ}, because \var s $\in \Sing{\text{\var t}}$ if and only if \var t $\equiv$ \var s.
  \item To define \coqdocdefinition{EQ} there is no other option than taking as definition exactly extensionality, \ie{} \\
  % 
  \centerline{
  \coqdocdefinition{EQ} \var s \var {s'} $\Leftrightarrow$ \coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvariable{t} \coqdocnotation{∈} \coqdocvariable{s} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \coqdocnotation{∈} \coqdocvariable{s'}.}
  
  This makes \coqdocdefinition{EQ} depend on \coqdocdefinition{IN}, which makes both definitions invalid because no argument is decreasing.
\end{itemize}

The most promising way to construct a model is actually to first simplify set expressions, finding a ``normal form'' which makes extensional equality as close as possible to intensional equality.

Let us point out that the real difference between the set operators in \NFTWO{} and \ZF{} is the complement ($\Complement \Placeholder$), which is not definable in \ZF{}. A good bet may be that in \NFTWO{} there exist two kinds of sets, which we call \emph{low} and \emph{high} (following \cite{Forster2001}). A low set is similar to a \ZF{} set in that it is a positive collection of sets; a high set, instead, is the complement of a low set, and its extension includes all sets but the ones in a given collection --- in terms of \ZF{}, it actually consists of a proper class. This bet is correct: as we will see in the next sections, low and high sets are stable under boolean combinations. Moreover, they satisfy extensionality.

\subsection{The Type \texorpdfstring{\coqdocinductive{SET}}{SET}}

To define the type of \NFTWO{} sets, we extend Aczel's construction to accommodate high sets, thus introducing an additonal constructor:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Inductive} \coqdefRef{NF2.Model.SET}{SET}{\coqdocinductive{SET}} :=\coqdoceol
  \coqdocindent{1.00em}
  \ensuremath{|} \coqdef{NF2.Model.Low}{Low}{\coqdocconstructor{Low}} : \coqdocnotation{\ensuremath{\forall}} \coqdocvar{X}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NF2.Model.SET}{\coqdocinductive{SET}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NF2.Model.SET}{\coqdocinductive{SET}}\coqdoceol
  \coqdocindent{1.00em}
  \ensuremath{|} \coqdef{NF2.Model.High}{High}{\coqdocconstructor{High}} : \coqdocnotation{\ensuremath{\forall}} \coqdocvar{X}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NF2.Model.SET}{\coqdocinductive{SET}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NF2.Model.SET}{\coqdocinductive{SET}}
  .\coqdoceol
  \coqdocemptyline
\end{coqdoccode}

Note that the indexing function \var f in the set \var s = \coqdef{NF2.Model.High}{High}{\coqdocconstructor{High}} \var X \var f does not actually index the sets in the extension of \var s, but the sets that are \emph{not} in the extension of \var s (because a high set is supposed to represent a complement).

\begin{example}[Empty set and Universe]\label{ex:EUNF2}
The empty set is defined as a low set with empty index:

  \begin{coqdoccode}
    \coqdocnoindent
    \coqdockw{Definition} \coqdocdefinition{Ø} := \coqdocconstructor{Low} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{x} \coqdockw{with} \coqdockw{end}).\coqdoceol
    \coqdocemptyline
  \end{coqdoccode}

  In a fully specular way, the universal set is defined as a \emph{high} set with empty index:

  \begin{coqdoccode}
    \coqdocnoindent
    \coqdockw{Definition} \coqdocdefinition{U} := \coqdocconstructor{High} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{x} \coqdockw{with} \coqdockw{end}).\coqdoceol
    \coqdocemptyline
  \end{coqdoccode}
\end{example}

\subsection{Set Equality}

To define equality of \NFO{} sets, we enforce our intuition that a low set cannot be equivalent to a high set (because high sets are much larger):

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Fixpoint} \coqdefRef{NF2.Model.EQ}{EQ}{\coqdocdefinition{EQ}} \coqdocvar{s} \coqdocvar{t} := \coqdockw{match} \coqdocvariable{s},\coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} \coqdocvar{\_}, \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} \coqdocvar{\_}, \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} \coqdocvar{f}, \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} \coqdocvar{g} \ensuremath{\Rightarrow} \coqdocvar{f} $\AEQ$ \coqdocvar{g} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} \coqdocvar{f}, \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} \coqdocvar{g} \ensuremath{\Rightarrow} \coqdocvar{f} $\AEQ$ \coqdocvar{g} \coqdoceol
\coqdocnoindent
\coqdockw{end}.\coqdoceol

\end{coqdoccode}

We are a bit cheating here: in fact, the notation for \AEQ{} hides a dependency on \coqdocdefinition{EQ}, which would actually make the \coqdockw{Fixpoint} definition fail as it conceals what argument is decreasing. For the actual \Coq{} definition, we inlined \coqdocdefinition{eq\_aczel} so to make \Coq{} recognise the decreasing argument. However, we decided to just use the succint notation above, so to help the intuition.

\medskip

Proving that \coqdocdefinition{EQ} is an equivalence relation goes smoothly and just like in \ZF{}; the only difference here is the cases to consider are doubled because of the two constructors:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Instance} \coqdefRef{NF2.Model.nf2 setoid}{nf2\_setoid}{\coqdocinstance{nf2\_setoid}} : \coqexternalref{Equivalence}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Classes.RelationClasses}{\coqdocclass{Equivalence}} \coqref{NF2.Model.EQ}{\coqdocdefinition{EQ}}.
\end{coqdoccode}

\subsection{Set Membership}

To define membership of \NFTWO{} sets, 

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Definition} \coqdefRef{NF2.Model.IN}{IN}{\coqdocdefinition{IN}} \coqdocvar{s} \coqdocvar{t} := \coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} \coqdocvar{f} \ensuremath{\Rightarrow} \coqdocvariable{s} \coqref{Internal.Common.in aczel}{\AIN} \coqdocvariable{f} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} \coqdocvar{f} \ensuremath{\Rightarrow} \coqdocvariable{s} \coqref{Internal.Common.in aczel}{$\not\AIN$} \coqdocvariable{f} \coqdoceol
\coqdocnoindent
\coqdockw{end}.\coqdoceol
\end{coqdoccode}

\medskip

Proving that \coqdocdefinition{IN} is a morphism goes smoothly and just like in \ZF{}:

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Add} \coqdockw{Morphism} \coqref{NF2.Model.IN}{\coqdocdefinition{IN}} \coqdockw{with} \coqdockw{signature} \coqref{NF2.Model.EQ}{\coqdocdefinition{EQ}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{$\Rightarrow$}} \coqref{NF2.Model.EQ}{\coqdocdefinition{EQ}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{$\Rightarrow$}} \coqexternalref{iff}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{iff}} \coqdockw{as} \coqdocdefinition{IN\_mor}.\coqdoceol
\coqdocnoindent
\end{coqdoccode}

\subsection{Set Operators}

Complementing a \NFTWO{} set is straighforward: the complement of a low set is a high set, and viceversa:

\begin{coqdoccode}
  \coqdockw{Definition} \coqdef{NF2.Sets.compl}{compl}{\coqdocdefinition{compl}} : \coqref{NF2.Model.SET}{\coqdocinductive{SET}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NF2.Model.SET}{\coqdocinductive{SET}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{s} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{s} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} \coqdocvar{f} \ensuremath{\Rightarrow} \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} \coqdocvar{f}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} \coqdocvar{f} \ensuremath{\Rightarrow} \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} \coqdocvar{f}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{NF2.Sets.compl ok}{compl\_ok}{\coqdoclemma{compl\_ok}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{t}, \coqdocvariable{s} \coqref{NF2.Model.:::x 'xE2x88x88' x}{\coqdocnotation{∈}} \coqref{NF2.Sets.compl}{\coqdocdefinition{compl}} \coqdocvariable{t} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{s} \coqref{NF2.Model.:::x 'xE2x88x88' x}{\coqdocnotation{∈}} \coqdocvariable{t} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  Just destruct \var t and apply few simplifications. Note: classical reasoning is required to turn a negated universal quantifier into an existential quantifier.
\end{proof}

A singleton is just a set whose indexing function is constant:

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Definition} \coqdef{NF2.Sets.sing}{sing}{\coqdocdefinition{sing}} : \coqref{NF2.Model.SET}{\coqdocinductive{SET}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NF2.Model.SET}{\coqdocinductive{SET}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{s} \ensuremath{\Rightarrow} \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqexternalref{unit}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{unit}} (\coqdockw{fun} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvariable{s}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{NF2.Sets.sing ok}{sing\_ok}{\coqdocdefinition{sing\_ok}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{t}, \coqdocvariable{s} \coqref{NF2.Model.:::x 'xE2x88x88' x}{\coqdocnotation{∈}} \coqref{NF2.Sets.sing}{\coqdocdefinition{sing}} \coqdocvariable{t} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \coqref{NF2.Model.:::x 'xE2x89xA1' x}{\coqdocnotation{≡}} \coqdocvariable{s}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

The definition of set union is slightly more involved, but straightforward. It relies on additional functions \coqdocdefinition{minus}, \coqdocdefinition{join} and \coqdocdefinition{meet} to perform respectively the set difference, intersection, and union of indexing functions. The various cases in the definition follow directly from the laws of boolean logic:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Definition} \coqdef{NF2.Sets.cup}{cup}{\coqdocdefinition{cup}} \coqdocvar{s} \coqdocvar{s'} := \coqdockw{match} \coqdocvariable{s}, \coqdocvariable{s'} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} \coqdocvar{f}, \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} \coqdocvar{g} \ensuremath{\Rightarrow} \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} (\coqref{NF2.Sets.minus}{\coqdocdefinition{minus}} \coqdocvar{g} \coqdocvar{f})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} \coqdocvar{f}, \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} \coqdocvar{g} \ensuremath{\Rightarrow} \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} (\coqref{NF2.Sets.minus}{\coqdocdefinition{minus}} \coqdocvar{f} \coqdocvar{g})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} \coqdocvar{f}, \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} \coqdocvar{g} \ensuremath{\Rightarrow} \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} (\coqref{NF2.Sets.join}{\coqdocdefinition{join}} \coqdocvar{f} \coqdocvar{g})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} \coqdocvar{f}, \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{\_} \coqdocvar{g} \ensuremath{\Rightarrow} \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{\_} (\coqref{NF2.Sets.meet}{\coqdocdefinition{meet}} \coqdocvar{f} \coqdocvar{g})\coqdoceol
\coqdocnoindent
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{NF2.Sets.:::x 'xE2x88xAA' x}{"}{"}A ∪ B" := (\coqref{NF2.Sets.cup}{\coqdocdefinition{cup}} \coqdocvar{A} \coqdocvar{B}) (\coqdoctac{at} \coqdockw{level} 85).\coqdoceol
\coqdocemptyline
\end{coqdoccode}

As an example, we provide the definition of \coqdocdefinition{minus} (the others are similar):

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Definition} \coqdef{NF2.Sets.minus}{minus}{\coqdocdefinition{minus}} \{\coqdocvar{X} \coqdocvar{Y}\} \coqdocvar{f} \coqdocvar{g} \coqdoceol
  \coqdocindent{1.00em}
  : \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{x} \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvariable{X} \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\&}} \coqdockw{\ensuremath{\forall}} \coqdocvar{y} : \coqdocvariable{Y}, \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{g} \coqdocvariable{y} \coqref{NF2.Model.:::x 'xE2x89xA1' x}{\coqdocnotation{≡}} \coqdocvariable{f} \coqdocvariable{x}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NF2.Model.SET}{\coqdocinductive{SET}} \coqdoceol
\coqdocindent{1.00em}:=
\coqref{Internal.Misc.select}{\coqdocdefinition{select}} \coqdocvariable{f} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdockw{\ensuremath{\forall}} \coqdocvar{y}, \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{g} \coqdocvariable{y} \coqref{NF2.Model.:::x 'xE2x89xA1' x}{\coqdocnotation{≡}} \coqdocvariable{f} \coqdocvariable{x}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}

It requires an auxiliary function \coqdocdefinition{select} \var f \var P that restricts the domain of a function \var f according to a predicate \var P:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Definition} \coqdef{Internal.Misc.select}{select}{\coqdocdefinition{select}} \{\coqdocvar{X} \coqdocvar{Y}\} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}) (\coqdocvar{P}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) \coqdoceol
  \coqdocindent{1.00em} : \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\{}}\coqdocvar{x}\coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvariable{X} \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\&}} \coqdocvariable{P} \coqdocvariable{x}\coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}\coqdoceol
  \coqdocindent{1.00em}
  := \coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvariable{f} (\coqexternalref{projT1}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvariable{x}).\coqdoceol
  \coqdocemptyline
\end{coqdoccode}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{NF2.Sets.cup ok}{cup\_ok}{\coqdoclemma{cup\_ok}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{s'} \coqdocvar{t}, \coqdocvariable{t} \coqref{NF2.Model.:::x 'xE2x88x88' x}{\coqdocnotation{∈}} \coqref{NF2.Model.:::x 'xE2x88x88' x}{\coqdocnotation{(}}\coqdocvariable{s} \coqref{NF2.Sets.:::x 'xE2x88xAA' x}{\coqdocnotation{∪}} \coqdocvariable{s'}\coqref{NF2.Model.:::x 'xE2x88x88' x}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{t} \coqref{NF2.Model.:::x 'xE2x88x88' x}{\coqdocnotation{∈}} \coqdocvariable{s}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{t} \coqref{NF2.Model.:::x 'xE2x88x88' x}{\coqdocnotation{∈}} \coqdocvariable{s'}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\end{coqdoccode}

\subsection{Extensionality}
Proving extensionality in \NFTWO{} is slightly more involved than in \ZF{}. Like in \ZF{}, one direction of the double implication is easy and follows directly from \coqdocdefinition{in\_sound\_right}.

As for the other direction, \ie{} \\
\centerline{
  (\coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvariable{t} \INX \coqdocvariable{s} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \INX \coqdocvariable{s'}) %
  \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\to}}} %
  \coqdocvariable{s} \EQX \coqdocvariable{s'}
}

\noindent
we proceed by cases over \var s and \var{s'}. When their constructor matches (cases \coqdocconstructor{Low}/\coqdocconstructor{Low} and \coqdocconstructor{High}/\coqdocconstructor{High}) the proof proceeds just like in \ZF{}. The new cases \coqdocconstructor{Low} \emph{vs} \coqdocconstructor{High} require some more work. In these cases, \coqdocvariable{s} \EQX \coqdocvariable{s'} does not hold because low sets and high sets are not equivalent by definition of \coqdocdefinition{EQ}. Therefore to conclude it suffices to assume \coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvariable{t} \INX \coqdocvariable{s} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \INX \coqdocvariable{s'} and derive a contradiction.

Without loss of generality, let us say that \var s = \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvar{X} \coqdocvar{f} and \var {s'} = \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvar{Y} \coqdocvar{g} (the other case is specular). Basically, what we have to prove is that a low set and a high set cannot have the same extension (upcoming lemma \coqref{NF2.Ext.pos neg ext neq}{\coqdoclemma{pos\_neg\_ext\_neq}}), which is justified by our initial intuition that low sets are ``small'', while high sets correspond to proper classes.

\medskip

The crucial intuition is that when a low set has the same extension as a high set, it is actually possible to construct a universal set that is low (contrarily to the universal set defined in \Cref{ex:EUNF2}, which is correctly high). In fact, the images of \var f and \var g are complementary, and it suffices to take their disjoin union:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdefRef{NF2.Ext.pos univ}{pos\_univ}{\coqdoclemma{pos\_univ}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{X} \coqdocvar{f} \coqdocvar{Y} \coqdocvar{g},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqdocvariable{s} \INX \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvariable{X} \coqdocvariable{f} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s} \INX \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvariable{Y} \coqdocvariable{g}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqdocvariable{s} \INX \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} (\coqdocvariable{X} \coqexternalref{::type scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{+}} \coqdocvariable{Y}) (\coqdocvariable{f} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{g}).\coqdoceol
\end{coqdoccode}
\begin{proof}
  Note: classical logic is required to prove this lemma.
  Assume $\coqdocvariable{s} \colon \coqdocinductive{SET}$. To show that \coqdocvariable{s} \INX \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} (\coqdocvariable{X} \coqexternalref{::type scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{+}} \coqdocvariable{Y}) (\coqdocvariable{f} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{g}), we need to supply an element of type \coqdocvariable{X} \coqexternalref{::type scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{+}} \coqdocvariable{Y}. Choosing the left or right injection into \coqdocvariable{X} \coqexternalref{::type scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{+}} \coqdocvariable{Y} is equivalent to deciding whether \coqdocvariable{s} \INX \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvariable{X} \coqdocvariable{f} holds.
  % \TODO{}
\end{proof}

To conclude, we just need to show that a universal set cannot be low. We resort to a form of ``regularity'' of low sets. Recall that regularity is an axiom of \ZF{} set theory which fundamentally forces sets to be well-founded. Clearly regularity does not hold in \NFTWO{}, since set membership is clearly not well-founded --- for instance, $\Universe \in \Universe \in \ldots$. However, a weaker form of regularity holds for low sets, namely that a low set cannot contain itself:

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Theorem} \coqdefRef{NF2.Ext.weak regularity}{weak\_regularity}{\coqdoclemma{weak\_regularity}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqref{NF2.Model.low}{\coqdocdefinition{low}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \INX \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  By structural induction on \coqdocvariable{s}, low by hypothesis. Let \coqdocvariable{s} = \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvariable{X} \coqdocvariable{f}. From \coqdocvariable{s} \INX \coqdocvariable{s} it follows that there exists \coqdocvariable{x} such that \coqdocvariable{s} \EQX \coqdocvariable{f}~\coqdocvariable{x}. Note that \coqdocvariable{f}~\coqdocvariable{x} must be a low set by the definition of \coqdocdefinition{EQ}. Since \coqdocdefinition{IN} is a \coqdocdefinition{EQ}-morphism, it follows that \coqdocvariable{f}~\coqdocvariable{x} \INX \coqdocvariable{f}~\coqdocvariable{x}. We conclude by the inductive hypothesis.
\end{proof}

It directly follows:

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Lemma} \coqdefRef{NF2.Ext.pos neg ext neq}{pos\_neg\_ext\_neq}{\coqdoclemma{pos\_neg\_ext\_neq}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{X} \coqdocvar{f} \coqdocvar{Y} \coqdocvar{g},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqdocvariable{s} \INX \coqref{NF2.Model.Low}{\coqdocconstructor{Low}} \coqdocvariable{X} \coqdocvariable{f} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s} \INX \coqref{NF2.Model.High}{\coqdocconstructor{High}} \coqdocvariable{Y} \coqdocvariable{g} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  By \coqref{NF2.Ext.pos univ}{\coqdoclemma{pos\_univ}} and \coqref{NF2.Ext.weak regularity}{\coqdoclemma{weak\_regularity}}.
\end{proof}

We are now ready to prove extensionality for \NFTWO:

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Theorem} \coqdefRef{NF2.Ext.ext}{ext}{\coqdoclemma{ext}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{s'}, \coqdocvariable{s} \EQX \coqdocvariable{s'} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvariable{t} \INX \coqdocvariable{s} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \INX \coqdocvariable{s'}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  The direction $(\Rightarrow)$ of the double implication follows from \coqdocdefinition{IN} being an \coqdocdefinition{EQ}-morphism. As for the other direction, we proceed by cases on \coqdocvariable{s} and \coqdocvariable{s'}:
  \begin{itemize}
    \item If \coqdocvariable{s} and \coqdocvariable{s'} are both low sets or both high sets, then the proof carries on exactly as in \ZF.
    \item The cases when one is a low set and the other one is a high set are ruled out by lemma \coqref{NF2.Ext.pos neg ext neq}{\coqdoclemma{pos\_neg\_ext\_neq}}.
    \qedhere
  \end{itemize}
\end{proof}
