%!TEX root = main.tex

\renewcommand\INX{\coqref{NFO.In.IN}{{\IN}}~}

\NFO{} is the sub-theory of \NF{} characterized by the axioms of \NFTWO{}, plus the essence ($\Essence\Placeholder$) and its characterizing axiom. As we will see, a model of \NFO{} is quite more involved than the one of \NFTWO{}, mainly because the syntactic difference between low sets and high will disappear.

\medskip

To find a model for \NFO{} we can reason on the normal forms of expressions of sets, as adviced in the previous section.
% 
Let us use (informally) a form of \emph{disjunctive normal form}, transforming a set expression through boolean transformation to a normal form made up of disjunctions of conjunctions, where complements are pushed to the inner atoms. The inner conjuctions have the following form:
\[\bigcap_i\Essence{s_i}\cap \bigcap_j \Complement{\Essence{t_j}} \cap \bigcap_k \Sing{u_k} \cap \bigcap_h \Complement{\Sing{v_h}}\]
They can contain positive or negated essence sets $\Essence\Placeholder$, and positive or negated singletons $\Sing\Placeholder$.

\begin{itemize}
  \item 
    If a such a conjunction contains at least a positive singleton, than it is equivalent either to it, or to the empty set.
  \item If instead it does not contain any positive singleton ($k=0$), then it can be rewritten informally as:
  \[\left(\bigcap_i\Essence{s_i}\cap \bigcap_j \Complement{\Essence{t_j}}\right) \setminus \{v_1, \ldots, v_H\} \]
\end{itemize}

By gathering the singleton-only disjuncts and permutating the differences of low sets outside of the disjunction, one can obtain a normal form like:

\[\A \cup (\B \setminus \A')\]

where $\A$ and $\A'$ are low sets, and $\B$ is a boolean combination of positive and negated essence sets. A further and cleaner normal form can be obtained by replacing the union and difference of low sets with a single symmetric difference of sets (denoted by $\triangle$), obtaining normal forms like $\A \triangle \B$ (called \emph{restricted word} in \cite{Forster2001}). We will call $\A$ and $\B$ respectively the \A-part (also, Aczel part) and the \B-part (also, essence part) of a \NFO{} set $\A \triangle \B$.

\bigskip

In our model, we will not actually enforce that the \B-part of a set is in any boolean normal form: the important point is that a \NFO{} set can be seen as composed of a low part, and a part due to essence expressions. Since boolean expressions play an important role in our model for \NFO{}, let us first define them formally in the next subsection.

\subsection{Boolean expressions}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
We use the inductive type @\coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}} \coqdocvar{X} to encode a boolean expression whose atoms have type \coqdocvar{X}:

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdefRef{NFO.BoolExpr.BExpr}{BExpr}{\coqdocinductive{BExpr}} \{\coqdocvar{X}\} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdefRef{NFO.BoolExpr.Bot}{Bot}{\coqdocconstructor{Bot}} : \coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdefRef{NFO.BoolExpr.Atom}{Atom}{\coqdocconstructor{Atom}} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdefRef{NFO.BoolExpr.Not}{Not}{\coqdocconstructor{Not}} : \coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdefRef{NFO.BoolExpr.Or}{Or}{\coqdocconstructor{Or}} : \coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\coqref{NFO.BoolExpr.Bot}{\coqdocconstructor{Bot}} represents the constant false expression, \coqref{NFO.BoolExpr.Or}{\coqdocconstructor{Or}} and \coqref{NFO.BoolExpr.Not}{\coqdocconstructor{Not}} the usual boolean operators, and \coqref{NFO.BoolExpr.Atom}{\coqdocconstructor{Atom}} an atom of type \var X. We did not add constructors for further logical connectives, like conjunction or implication, because disjunction and complement are functionally complete for classical logic.

\medskip

We now define a few important functions of boolean expressions. The usual \coqdocdefinition{map} function that applies a function \var f to the atoms of a boolean expression:

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdefRef{NFO.BoolExpr.map}{map}{\coqdocdefinition{map}} \{\coqdocvar{X} \coqdocvar{Y}\} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}) (\coqdocvar{e}: \coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}}) : \coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}} :=\coqdoceol
\coqdocnoindent
\coqdockw{match} \coqdocvariable{e} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NFO.BoolExpr.Atom}{\coqdocconstructor{Atom}} \coqdocvar{a} \ensuremath{\Rightarrow} \coqref{NFO.BoolExpr.Atom}{\coqdocconstructor{Atom}} (\coqdocvariable{f} \coqdocvar{a})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NFO.BoolExpr.Bot}{\coqdocconstructor{Bot}} \ensuremath{\Rightarrow} \coqref{NFO.BoolExpr.Bot}{\coqdocconstructor{Bot}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NFO.BoolExpr.Not}{\coqdocconstructor{Not}} \coqdocvar{e} \ensuremath{\Rightarrow} \coqref{NFO.BoolExpr.Not}{\coqdocconstructor{Not}} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{e})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NFO.BoolExpr.Or}{\coqdocconstructor{Or}} \coqdocvar{e} \coqdocvar{e'} \ensuremath{\Rightarrow} \coqref{NFO.BoolExpr.Or}{\coqdocconstructor{Or}} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{e}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvar{e'})\coqdoceol
\coqdocnoindent
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

Evaluate a boolean expression to a \coqdockw{Prop} 
(when atoms have type \coqdockw{Prop}):

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdefRef{NFO.BoolExpr.eval}{eval}{\coqdocdefinition{eval}} (\coqdocvar{e}: \coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}}) := \coqdockw{match} \coqdocvariable{e} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NFO.BoolExpr.Atom}{\coqdocconstructor{Atom}} \coqdocvar{p} \ensuremath{\Rightarrow} \coqdocvar{p}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NFO.BoolExpr.Bot}{\coqdocconstructor{Bot}} \ensuremath{\Rightarrow} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NFO.BoolExpr.Not}{\coqdocconstructor{Not}} \coqdocvar{e} \ensuremath{\Rightarrow} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{NFO.BoolExpr.eval}{\coqdocdefinition{eval}} \coqdocvariable{e}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{NFO.BoolExpr.Or}{\coqdocconstructor{Or}} \coqdocvar{e} \coqdocvar{e'} \ensuremath{\Rightarrow} \coqref{NFO.BoolExpr.eval}{\coqdocdefinition{eval}} \coqdocvariable{e} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqref{NFO.BoolExpr.eval}{\coqdocdefinition{eval}} \coqdocvar{e'}\coqdoceol
\coqdocnoindent
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdefRef{NFO.BoolExpr.:::'xE2x9FxA6' x 'xE2x9FxA7'}{"}{"}⟦ e ⟧" := (\coqref{NFO.BoolExpr.eval}{\coqdocdefinition{eval}} \coqdocvar{e}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\subsubsection{Semantics}

As usual, two boolean expressions (with atoms of type \coqdocvariable{X}) are equivalent if and only if 
they evaluate to equivalent values with respect to every
truth assignment \coqdocvar{P}: \coqdocvariable{X} \coqdocnotation{\ensuremath{\rightarrow}} \coqdockw{Prop}. However, not every assignment is allowed here.
In our case, the set of atoms \coqdocvariable{X} will ultimately be instantiated to \coqdocdefinition{SET}, which is equipped with a setoid structure, hence $\coqdocvar{P}$ must assign the same truth value to atoms that are equivalent according to $\coqdocdefinition{EQ}$. In general, $\coqdocvar{P}$ should be a $(\coqdocvariable{X}, \coqdocvar{R})$-morphism, \ie{} it should respect a binary relation $\coqdocvar{R}$ given in input.

\begin{coqdoccode}
  \coqdocemptyline
  \coqdocnoindent
\coqdockw{Definition} \coqdef{Internal.FunExt.respects}{respects}{\coqdocdefinition{respects}} \{\coqdocvar{X}\} \coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{R}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) (\coqdocvar{P}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) \coqdoceol
\coqdocindent{1.00em}
:= \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{x'}, \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{x'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqdocvariable{x} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{P} \coqdocvariable{x'}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdefRef{NFO.BoolExpr.eq\_bexpr}{eq\_bexpr}{\coqdocdefinition{eq\_bexpr}} \{\coqdocvar{X}\} (\coqdocvar{R}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) \coqdocvar{e} \coqdocvar{e'} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{P}, \coqref{Internal.FunExt.respects}{\coqdocdefinition{respects}} \coqdocvariable{R} \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.BoolExpr.:::'xE2x9FxA6' x 'xE2x9FxA7'}{\coqdocnotation{⟦}}\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{P} \coqdocvariable{e}\coqref{NFO.BoolExpr.:::'xE2x9FxA6' x 'xE2x9FxA7'}{\coqdocnotation{⟧}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{NFO.BoolExpr.:::'xE2x9FxA6' x 'xE2x9FxA7'}{\coqdocnotation{⟦}}\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{P} \coqdocvariable{e'}\coqref{NFO.BoolExpr.:::'xE2x9FxA6' x 'xE2x9FxA7'}{\coqdocnotation{⟧}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\subsection{The Type \texorpdfstring{\coqdocinductive{SET}}{SET}}

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Inductive} \coqdefRef{NFO.Model.SET}{SET}{\coqdocinductive{SET}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdef{NFO.Model.S}{S}{\coqdocconstructor{S}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} \coqdocvar{Y} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}) (\coqdocvar{g}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}) (\coqdocvar{e}: @\coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}} \coqdocvariable{Y}), \coqref{NFO.Model.SET}{\coqdocinductive{SET}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

In a set \coqdef{NFO.Model.S}{S}{\coqdocconstructor{S}} \var X \var Y \var f \var g \var e, the \A-part consists of \var X and \var f, and the \B-part consists of \var Y, \var g, \var e. We need a separate index \var Y for the atoms of the boolean expression \var e: the atoms of \var e cannot have type directly \coqdocinductive{SET}, as this would not make \Coq{} accept the inductive definition.

\begin{example}[Injection \NFTWO{} $\hookrightarrow$ \NFO{}]
  Just to help the intuition, we provide an informal injection of \NFTWO{} sets into \NFO{} sets:

  \begin{tabular}{ccl}
    \coqdef{NF2.Model.High}{High}{\coqdocconstructor{High}} \coqdocvariable{X} \coqdocvariable{f} & $\hookrightarrow$ & \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvariable{X} ${\_}_1$ \coqdocvariable{f} ${\_}_2$ \coqref{NFO.BoolExpr.Bot}{\coqdocconstructor{Bot}}
    \\
    \coqdef{NF2.Model.Low}{Low}{\coqdocconstructor{Low}} \coqdocvariable{X} \coqdocvariable{f} & $\hookrightarrow$ & \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvariable{X} ${\_}_1$ \coqdocvariable{f} ${\_}_2$ (\coqref{NFO.BoolExpr.Not}{\coqdocconstructor{Not}} \coqref{NFO.BoolExpr.Bot}{\coqdocconstructor{Bot}})
  \end{tabular}
  
\end{example}


where ${\_}_1$ and ${\_}_2$ can really be anything (for simplicity, one can take respectively \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} and \coqexternalref{False rect}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{False\_rect}} \coqdocvar{\_}) .

\subsection{Set Equality}

We say that two \NFO{} sets are equivalent if and only if their \A-parts and \B-parts are equivalent, respectively. Unfortunately, such a straightforward definition cannot be accepted by \Coq:

\begin{coqdoccode}
  \coqdocemptyline
\coqdocnoindent
\sout{\coqdockw{Fixpoint}} \coqdoclemma{EQ} \coqdocvar{s} \coqdocvar{s'} := \coqdockw{match} \coqdocvariable{s}, \coqdocvariable{s'} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X'} \coqdocvar{Y'} \coqdocvar{f'} \coqdocvar{g'} \coqdocvar{e'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqdoceol

\coqdocindent{4.00em} \coqdocvar{f} $\AEQ$ \coqdocvar{f'} % \coqdoceol
% 
% \coqdocindent{4.00em}
 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{NFO.BoolExpr.eq bexpr}{\coqdocdefinition{eq\_bexpr}} \coqref{NFO.Eq.EQ}{\coqdocdefinition{EQ}} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g'} \coqdocvariable{e'}).\coqdoceol
 \coqdocemptyline
\end{coqdoccode}

The reason is that \coqdocdefinition{eq\_bexpr} takes \coqdocdefinition{EQ} itself as argument, making the definition not decreasing in any argument. Inlining \coqdocdefinition{eq\_bexpr} does not help here, because \coqdocdefinition{respects} actually quantifies over all sets and uses \coqdocdefinition{EQ} over them.

It is necessary to provide a different, less intuitive, but hopefully equivalent definition for \coqdocdefinition{EQ}, so that \Coq{} can recognize termination. We need to perform a few changes to our definition:

\begin{itemize}
  \item A crucial observation is that, in order to compute \coqref{NFO.BoolExpr.eq bexpr}{\coqdocdefinition{eq\_bexpr}} \coqref{NFO.Eq.EQ}{\coqdocdefinition{EQ}} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g'} \coqdocvariable{e'}), it is not actually required the value of \coqdocdefinition{EQ} over its whole domain. When quantifying over all truth assignments \var P to check the equivalence of the two boolean expressions \coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e} and \coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g'} \coqdocvariable{e'}, the assignment \var P will after all be applied only to sets that are in the image of \var g or \var {g'}.
  
  The solution is to delay the mapping of \var g and \var{g'}, and to restrict the domain of \coqdocdefinition{EQ} to the disjoint union of the images of \var g and \var{g'}. The following lemma states that our proposed change is equivalent to the original definition:

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdefRef{NFO.BoolExpr.eq bexpr simpl}{eq\_bexpr\_simpl}{\coqdoclemma{eq\_bexpr\_simpl}}:\coqdoceol
\coqdocindent{0.50em}
\coqdockw{\ensuremath{\forall}} \{\coqdocvar{Y} \coqdocvar{Y'} \coqdocvar{Z} \coqdocvar{R}\} \{\coqdocvar{g}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}\} \{\coqdocvar{g'}: \coqdocvariable{Y'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}\} \{\coqdocvar{e} \coqdocvar{e'}\},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Equivalence}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Classes.RelationClasses}{\coqdocclass{Equivalence}} \coqdocvariable{R} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{NFO.BoolExpr.eq bexpr}{\coqdocdefinition{eq\_bexpr}} (\coqdocvariable{R} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{⨀}} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{(}}\coqdocvariable{g} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{g'}\coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{)}}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvariable{e}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvariable{e'})\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{NFO.BoolExpr.eq bexpr}{\coqdocdefinition{eq\_bexpr}} \coqdocvariable{R} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g'} \coqdocvariable{e'}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}

  where ⨀ is the composition of a predicate with a function on both its arguments:

  \begin{coqdoccode}
    \coqdocnoindent
    \coqdockw{Definition} \coqdef{Internal.Misc.compR}{compR}{\coqdocdefinition{compR}} \{\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z}\}\coqdoceol
    \coqdocindent{1.00em}
    (\coqdocvar{R}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}) (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}) \coqdocvar{x} \coqdocvar{x'} \coqdoceol
    \coqdocindent{1.00em} := \coqdocvariable{R} (\coqdocvariable{f} \coqdocvariable{x}) (\coqdocvariable{f} \coqdocvariable{x'}).\coqdoceol
    \coqdocnoindent
    \coqdockw{Infix} \coqdef{Internal.Misc.:::x 'xE2xA8x80' x}{"}{"}⨀" := \coqref{Internal.Misc.compR}{\coqdocdefinition{compR}} (\coqdoctac{at} \coqdockw{level} 79).\coqdoceol
    \coqdocemptyline
  \end{coqdoccode}

  Note that lemma \coqref{NFO.BoolExpr.eq bexpr simpl}{\coqdoclemma{eq\_bexpr\_simpl}} crucially relies on \coqdocdefinition{EQ} being an equivalence relation: as a consequence, we are forced to prove first that \coqdocdefinition{EQ} is an equivalence using the more involved definition, and only afterwards we will be able to simplify back the definition using that lemma. 

  \item Note that in the point above we composed \var R with the sum \coqdocvariable{g} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{g'}, which causes occurrences of not only \coqdocdefinition{EQ} (\var g \Placeholder) (\var {g'} \Placeholder), but also all other combinations \coqdocdefinition{EQ} (\var g \Placeholder) (\var {g} \Placeholder), \coqdocdefinition{EQ} (\var {g'} \var \Placeholder) (\var g \Placeholder), and \coqdocdefinition{EQ} (\var {g'} \Placeholder) (\var {g'} \Placeholder). This is required, because in order to know if an assignment \var P is admissible, it is not only necessary to know how the sets in the image of \var g compare to the ones in the image of \var{g'}, but also how sets in the same image compare to themselves.

  \item A consequence of the point above is that \coqdocdefinition{EQ} will not be not strictly decreasing in any single one of its arguments, even thought its arguments decrease as a whole. The solution is to first define a \emph{uncurried} version of \coqdocdefinition{EQ}, which we call \coqdocdefinition{EQ'}, taking in input a pair of sets. We can easily define the curried version afterwards.
\end{itemize}

Here is the complete definition of \coqdocdefinition{EQ'}, using a \coqdocdefinition{Fix} over the custom well-founded order \coqref{Internal.WfTuples.wf two}{\coqdoclemma{wf\_two}} \coqref{NFO.Model.wf lt}{\coqdoclemma{wf\_lt}} (we will discuss this order in \Cref{subsubs:wfo}):

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Local} \coqdockw{Definition} \coqdefRef{NFO.Eq.EQ'}{EQ'}{\coqdocdefinition{EQ'}} : \coqref{NFO.Model.SET}{\coqdocinductive{SET}} \coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}.\coqdoceol
\coqdocnoindent
\coqdoctac{refine} ( \coqexternalref{Fix}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Wf}{\coqdocdefinition{Fix}} (\coqref{Internal.WfTuples.wf two}{\coqdoclemma{wf\_two}} \coqref{NFO.Model.wf lt}{\coqdoclemma{wf\_lt}}) (\coqdockw{fun} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdockw{Prop}) (\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{p} \coqdocvar{rec} \ensuremath{\Rightarrow} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{as} \coqdocvar{p0} \coqdockw{return} (\coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p0} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X'} \coqdocvar{Y'} \coqdocvar{f'} \coqdocvar{g'} \coqdocvar{e'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqdockw{fun} \coqdocvar{eqx} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{((}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x'}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{rec} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{f} \coqdocvariable{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{f'} \coqdocvariable{x'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqdocvar{\_}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{4.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x'}, \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{rec} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{f} \coqdocvariable{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{f'} \coqdocvariable{x'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqdocvar{\_}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{))}}\coqdoceol
\coqdocindent{4.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdockw{let} \coqdocvar{R} (\coqdocvar{yy} \coqdocvar{yy'}: \coqdocvar{Y} \coqexternalref{::type scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{+}} \coqdocvar{Y'}) := \coqdockw{match} \coqdocvariable{yy}, \coqdocvariable{yy'} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{y}, \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{y'} \ensuremath{\Rightarrow} \coqdocvariable{rec} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{g} \coqdocvar{y}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{g} \coqdocvar{y'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqdocvar{\_}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{y}, \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvar{y'} \ensuremath{\Rightarrow} \coqdocvariable{rec} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{g} \coqdocvar{y}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{g'} \coqdocvar{y'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqdocvar{\_}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvar{y}, \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{y'} \ensuremath{\Rightarrow} \coqdocvariable{rec} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{g'} \coqdocvar{y}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{g} \coqdocvar{y'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqdocvar{\_}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvar{y}, \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvar{y'} \ensuremath{\Rightarrow} \coqdocvariable{rec} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{g'} \coqdocvar{y}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{g'} \coqdocvar{y'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqdocvar{\_}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{end} \coqdoctac{in} \coqdoceol
\coqdocindent{5.00em}
\coqref{NFO.BoolExpr.eq bexpr}{\coqdocdefinition{eq\_bexpr}} \coqdocvariable{R} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{e}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvar{e'})\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}) \coqexternalref{eq refl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocconstructor{eq\_refl}}\coqdoceol
\coqdocindent{0.50em}
))\coqdoceol
\coqdocindent{0.50em}
; \coqdoctac{rewrite} \coqdocvar{eqx}; \coqdoctac{eauto} \coqdockw{with} \coqdocvar{Wff}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdefRef{NFO.Eq.EQ}{EQ}{\coqdocdefinition{EQ}} \coqdocvar{s} \coqdocvar{s'} := \coqref{NFO.Eq.EQ'}{\coqdocdefinition{EQ'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{s}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{s'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}.\coqdoceol
\end{coqdoccode}

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Infix} ``\ensuremath{\BEQ}'' := (\coqdocdefinition{eq\_bexpr} \coqdocdefinition{EQ}).\coqdoceol
  \coqdocemptyline
\end{coqdoccode}

\subsubsection{Detour: Well-founded Orders}
\label{subsubs:wfo}

As already mentioned, using \coqdocdefinition{Fix} from the \Coq's standard library requires to manually supply both a termination order, and a proof that the order is well-founded.

The definition of \coqdocdefinition{EQ'} given above, for instance, requires to prove well-founded the following order on 2-tuples:
% 
\[ (x, y) <_2 (w_1, w_2) \Leftrightarrow x < w_i \land y < w_j \land \{i,j\}\subseteq\{1,2\} \]

where $<$ is the natural, structural order on \NFO{} sets.

To later prove transitivity of \coqdocdefinition{EQ} (see \Cref{subsubs:back}), however, it will be necessary to prove well-founded a similar order on 3-tuples:
% 
\[\begin{array}{l}
  (x, y, z) <_3 (w_1, w_2, w_3) \\
  \hspace{1em}\Leftrightarrow x < w_i \land y < w_j \land z < w_k \land \{i,j,k\}\subseteq\{1,2,3\}
\end{array}\]

Both these orders can be seen as instances of the \emph{multiset} ordering induced by $<$:
\[ X \cup Y \prec X \cup \{y\} \Leftrightarrow Y \prec y \]
where $Y \prec y$ means that all elements of $Y$ are strictly smaller than $y$.

However the only existing formalization of well-foundedness of the multiset order that we are able to find was \cite{YYY}, which however requires that equality over elements of the multisets to be decidable. We decided to avoid using classical reasoning --- at least in the definition of \coqdocdefinition{EQ} --- since we plan to experiment with constructive variants of \NFO{} as future work (see \Cref{sub:future}).

We implemented our own formalization of the well-foundedness of the multiset ordering, using lists as underlying data structures and list permutation to emulate position irrelevance of multisets. Most importantly, our formalization does not require the equality of elements to be decidable. To formalize multiset ordering, we mostly followed \cite{ZZZ} by Tobias Nipkov, and we plan to release this library as a standalone \Coq{} library.

% Call $\prec$ this multiset ordering over lists.



% \coqexternalref{Fix}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Wf}{\coqdocdefinition{Fix}}

% \coqref{Internal.WfTuples.wf two}{\coqdoclemma{wf\_two}}

% le22 le33 From Internal.WfTuplesThen, we used 

% \[ (x, y) <_2 (x', y') \Rightarrow [x, y] \prec [x', y'] \]

% \[ (x, y, z) <_3 (x', y', z') \Rightarrow  [x, y, z] \prec [x', y', z'] \]

\subsubsection{Back to Equality}
\label{subsubs:back}

To prove that \coqdocdefinition{EQ} is an equivalence relation, we first have to prove that \coqdocdefinition{eq\_bexpr} is an equivalence relation.
Actually, we need to prove less intuitive variations of the usual reflexivity, symmetry and
trasitivity. These variants are exactly what is needed to prove
that equality of NFO sets is an equivalence relation (see NFO.Eeq).
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdefRef{NFO.BoolExpr.eq bexpr refl}{eq\_bexpr\_refl}{\coqdoclemma{eq\_bexpr\_refl}} \coqdocvar{X} \coqdocvar{Y} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}) (\coqdocvar{R}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) \coqdocvar{e}:\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{R} (\coqdocvariable{f} \coqdocvariable{x}) (\coqdocvariable{f} \coqdocvariable{x})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.BoolExpr.eq bexpr}{\coqdocdefinition{eq\_bexpr}} (\coqdocvariable{R} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{⨀}} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{(}}\coqdocvariable{f} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{f}\coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{)}}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvariable{e}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvariable{e}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdefRef{NFO.BoolExpr.eq bexpr sym}{eq\_bexpr\_sym}{\coqdoclemma{eq\_bexpr\_sym}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} \coqdocvar{R} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}) (\coqdocvar{g}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}) \coqdocvar{e} \coqdocvar{e'} :\coqdoceol
\coqdocindent{1.00em}
\coqref{NFO.BoolExpr.eq bexpr}{\coqdocdefinition{eq\_bexpr}} (\coqdocvariable{R} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{⨀}} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{(}}\coqdocvariable{f} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{g}\coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{)}}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvariable{e}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvariable{e'})\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.BoolExpr.eq bexpr}{\coqdocdefinition{eq\_bexpr}} (\coqdocvariable{R} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{⨀}} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{(}}\coqdocvariable{g} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{f}\coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{)}}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvariable{e'}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvariable{e}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdefRef{NFO.BoolExpr.eq bexpr trans}{eq\_bexpr\_trans}{\coqdoclemma{eq\_bexpr\_trans}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} \coqdocvar{W} (\coqdocvar{R} : \coqdocvariable{W} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{W} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop})\coqdoceol
\coqdocindent{0.50em} (\coqdocvar{f1} \coqdocvar{f2} \coqdocvar{f3})
(\coqdocvar{e1} : @\coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}} \coqdocvariable{X}) (\coqdocvar{e2} : @\coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}} \coqdocvariable{Y}) (\coqdocvar{e3} : @\coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}} \coqdocvariable{Z}) \coqdoceol
\coqdocindent{1.00em}
: \coqexternalref{Equivalence}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Classes.RelationClasses}{\coqdocclass{Equivalence}} (\coqdocvariable{R} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{⨀}} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{(}}\coqdocvariable{f1} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{f2} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{f3}\coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{)}})
\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.BoolExpr.eq bexpr}{\coqdocdefinition{eq\_bexpr}} (\coqdocvariable{R} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{⨀}} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{(}}\coqdocvariable{f1} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{f2}\coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{)}}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvariable{e1}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvariable{e2})\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.BoolExpr.eq bexpr}{\coqdocdefinition{eq\_bexpr}} (\coqdocvariable{R} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{⨀}} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{(}}\coqdocvariable{f2} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{f3}\coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{)}}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvariable{e2}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvariable{e3})\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.BoolExpr.eq bexpr}{\coqdocdefinition{eq\_bexpr}} (\coqdocvariable{R} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{⨀}} \coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{(}}\coqdocvariable{f1} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvariable{f3}\coqref{Internal.Misc.:::x 'xE2xA8x80' x}{\coqdocnotation{)}}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvariable{e1}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvariable{e3}).\coqdoceol
\end{coqdoccode}

Lifting these lemmas to prove that \coqdocdefinition{EQ} is an equivalence relation is non-trivial: it requires both the order $<_2$ (for symmetry) and the order $<_3$ (for transitivity), which are mentioned in \Cref{subsubs:wfo}.


\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Instance} \coqdef{NFO.Eq.nfo setoid}{nfo\_setoid}{\coqdocinstance{nfo\_setoid}} : \coqexternalref{Equivalence}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Classes.RelationClasses}{\coqdocclass{Equivalence}} \coqref{NFO.Eq.EQ}{\coqdocdefinition{EQ}}.\coqdoceol
  \coqdocemptyline
\end{coqdoccode}

We can finally apply lemma \coqref{NFO.BoolExpr.eq bexpr simpl}{\coqdoclemma{eq\_bexpr\_simpl}} and obtain a nice unfolding lemma for \coqdocdefinition{EQ}:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdef{NFO.Eq.EQ unfold}{EQ\_unfold}{\coqdoclemma{EQ\_unfold}} \{\coqdocvar{X'} \coqdocvar{Y'} \coqdocvar{f'} \coqdocvar{g'} \coqdocvar{e'} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{e}\}:\coqdoceol
  \coqdocindent{1.00em}
  \coqref{NFO.Eq.EQ}{\coqdocdefinition{EQ}} (\coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvariable{X} \coqdocvariable{Y} \coqdocvariable{f} \coqdocvariable{g} \coqdocvariable{e}) (\coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvariable{X'} \coqdocvariable{Y'} \coqdocvariable{f'} \coqdocvariable{g'} \coqdocvariable{e'})\coqdoceol
  \coqdocindent{2.00em}
  \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{f} \coqref{NFO.Eq.AEQ}{\coqdocabbreviation{\ensuremath{\AEQ}}} \coqdocvariable{f'} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e}) \coqref{NFO.Eq.BEQ}{\BEQ} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g'} \coqdocvariable{e'}).\coqdoceol
\end{coqdoccode}

\subsection{Set Membership}

Let us first define a predicate characterizing membership on the \B-part of a set:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Fixpoint} \coqdefRef{NFO.In.IN bexpr}{IN\_bexpr}{\coqdocdefinition{IN\_bexpr}} \{\coqdocvar{Z}\} (\coqdocvar{R}: \coqdocvariable{Z} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) \coqdocvar{y} (\coqdocvar{p}: \coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}}) := \coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
  \coqdocindent{1.00em}
  \ensuremath{|} \coqref{NFO.BoolExpr.Bot}{\coqdocconstructor{Bot}} \ensuremath{\Rightarrow} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}\coqdoceol
  \coqdocindent{1.00em}
  \ensuremath{|} \coqref{NFO.BoolExpr.Atom}{\coqdocconstructor{Atom}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvariable{R} \coqdocvar{x} \coqdocvariable{y}\coqdoceol
  \coqdocindent{1.00em}
  \ensuremath{|} \coqref{NFO.BoolExpr.Not}{\coqdocconstructor{Not}} \coqdocvar{p'} \ensuremath{\Rightarrow} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{NFO.In.IN bexpr}{\coqdocdefinition{IN\_bexpr}} \coqdocvariable{R} \coqdocvariable{y} \coqdocvar{p'}\coqdoceol
  \coqdocindent{1.00em}
  \ensuremath{|} \coqref{NFO.BoolExpr.Or}{\coqdocconstructor{Or}} \coqdocvar{p1} \coqdocvar{p2} \ensuremath{\Rightarrow} \coqref{NFO.In.IN bexpr}{\coqdocdefinition{IN\_bexpr}} \coqdocvariable{R} \coqdocvariable{y} \coqdocvar{p1} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqref{NFO.In.IN bexpr}{\coqdocdefinition{IN\_bexpr}} \coqdocvariable{R} \coqdocvariable{y} \coqdocvar{p2}\coqdoceol
  \coqdocnoindent
  \coqdockw{end}.\coqdoceol
\end{coqdoccode}

Since set membership is defined in terms of symmetric difference of set, we crucially need to defined the corresponding operatorion on proposition, \ie{} \emph{exclusive disjunction}:

\begin{coqdoccode}
  \coqdocemptyline
  \coqdocnoindent
  \coqdockw{Definition} \coqdefRef{NFO.Xor.xor}{xor}{\coqdocdefinition{xor}} \coqdocvar{p} \coqdocvar{q} := \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{p} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{q}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{p} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{q}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
  \coqdocnoindent
  \coqdockw{Infix} \coqdefRef{NFO.Xor.:::x 'xE2x8AxBB' x}{"}{"}⊻" := \coqref{NFO.Xor.xor}{\coqdocdefinition{xor}} (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
  \coqdocemptyline
\end{coqdoccode}

Like for \coqdocdefinition{EQ'}, we cannot define \coqdocdefinition{IN} directly, as it would not satisfy \Coq's criterion about strictly decreasing arguments:

\begin{coqdoccode}
  \coqdocnoindent
  \sout{\coqdockw{Fixpoint}} \coqdoclemma{IN} \coqdocvar{s} \coqdocvar{s'} := \coqdockw{match} \coqdocvariable{s'} \coqdockw{with}\coqdoceol
  \coqdocindent{2.00em}
  \ensuremath{|} \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{e} \ensuremath{\Rightarrow} \coqdocvar{s} \coqref{NFO.In.AIN}{\AIN} \coqdocvar{f}
  \XOR \coqref{NFO.In.IN bexpr}{\coqdocdefinition{IN\_bexpr}} \coqref{NFO.In.IN}{\coqdocdefinition{IN}} \coqdocvar{s} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e})\coqdoceol
  \coqdocnoindent \coqdockw{end}.
\end{coqdoccode}

We need to use the following equivalence, which makes the decreasing argument explicit:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdefRef{NFO.In.IN bexpr map2}{IN\_bexpr\_map2}{\coqdoclemma{IN\_bexpr\_map2}} \{\coqdocvar{X} \coqdocvar{Z}\} (\coqdocvar{R}: \coqdocvariable{Z} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) \coqdocvar{f} \coqdocvar{z} (\coqdocvar{e}: @\coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}} \coqdocvariable{X}):\coqdoceol
  \coqdocindent{1.00em}
  \coqref{NFO.BoolExpr.:::'xE2x9FxA6' x 'xE2x9FxA7'}{\coqdocnotation{⟦}} \coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvariable{R} (\coqdocvariable{f} \coqdocvariable{x}) \coqdocvariable{z}) \coqdocvariable{e} \coqref{NFO.BoolExpr.:::'xE2x9FxA6' x 'xE2x9FxA7'}{\coqdocnotation{⟧}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{NFO.In.IN bexpr}{\coqdocdefinition{IN\_bexpr}} \coqdocvariable{R} \coqdocvariable{z} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{e}).\coqdoceol
\end{coqdoccode}

ccc

\begin{coqdoccode}
  \coqdocemptyline
  \coqdocnoindent
  \coqdockw{Local} \coqdockw{Definition} \coqdefRef{NFO.In.IN'}{IN'}{\coqdocdefinition{IN'}} : \coqref{NFO.Model.SET}{\coqdocinductive{SET}} \coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}.\coqdoceol
  \coqdocindent{0.50em}
  \coqdoctac{refine} ( \coqexternalref{Fix}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Wf}{\coqdocdefinition{Fix}} (\coqexternalref{wf swapprod}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Wellfounded.Lexicographic\_Product}{\coqdoclemma{wf\_swapprod}} \coqdocvar{\_} \coqref{NFO.Wf.lt}{\coqdocinductive{lt}} \coqref{NFO.Wf.wf lt}{\coqdoclemma{wf\_lt}}) (\coqdockw{fun} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdockw{Prop}) \coqdoceol
  \coqdocindent{1.00em}
  (\coqdockw{fun} \coqdocvar{i} \coqdockw{rec} \ensuremath{\Rightarrow} \coqdoceol
  \coqdocindent{2.00em}
  (\coqdockw{match} \coqdocvariable{i} \coqdockw{as} \coqdocvar{i0} \coqdockw{return} (\coqdocvariable{i} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{i0} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) \coqdockw{with} \coqdoceol
  \coqdocindent{3.00em}
  \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{z}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}
  % \coqdoceol
  % 
  \ensuremath{\Rightarrow} \coqdockw{fun} \coqdocvar{eqx}   \ensuremath{\Rightarrow} \coqdoceol
  \coqdocindent{4.00em}
  \coqdocvar{z} \AIN ~\coqdocvar{f} \coqref{NFO.Xor.:::x 'xE2x8AxBB' x}{\coqdocnotation{⊻}} \coqref{NFO.BoolExpr.:::'xE2x9FxA6' x 'xE2x9FxA7'}{\coqdocnotation{⟦}} \coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdocvariable{rec} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{g} \coqdocvariable{y}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{z}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqdocvar{\_}) \coqdocvar{e} \coqref{NFO.BoolExpr.:::'xE2x9FxA6' x 'xE2x9FxA7'}{\coqdocnotation{⟧}} \coqdoceol
  \coqdocindent{2.00em}
  \coqdockw{end}) \coqexternalref{eq refl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocconstructor{eq\_refl}} 
  )).\coqdoceol
  \coqdocnoindent
  [...] \coqdockw{Defined}.\coqdoceol
  \coqdocnoindent
  \coqdockw{Definition} \coqdefRef{NFO.In.IN}{IN}{\coqdocdefinition{IN}} \coqdocvar{s} \coqdocvar{s'} := \coqref{NFO.In.IN'}{\coqdocdefinition{IN'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{s}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{s'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

% \TODO{Spiegare il well-order}

We can now provide a notation for membership in the \B-part:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Infix} ``\BIN'' := (\coqdocdefinition{in\_bexpr} \coqdocdefinition{IN}).\coqdoceol
\end{coqdoccode}

Finally, we obtain the nice simplification lemma for \coqdocdefinition{IN}:
  \begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdefRef{NFO.In.IN unfold}{IN\_unfold}{\coqdoclemma{IN\_unfold}} \{\coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{e} \coqdocvar{s}\} :\coqdoceol
  \coqdocindent{1.00em}
  \coqdocvariable{s} \INX \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvariable{X} \coqdocvariable{Y} \coqdocvariable{f} \coqdocvariable{g} \coqdocvariable{e} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s} \coqref{NFO.In.AIN}{\AIN} \coqdocvariable{f} \coqref{NFO.Xor.:::x 'xE2x8AxBB' x}{\coqdocnotation{⊻}} \coqdocvariable{s} \coqref{NFO.In.BIN}{\BIN} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{e}).\coqdoceol
\end{coqdoccode}
\begin{proof}
  By \coqref{NFO.In.IN bexpr map2}{\coqdoclemma{IN\_bexpr\_map2}}.
\end{proof}

Proving \coqdoclemma{IN\_respects\_EQ} for \NFO{} is more involved than in the previous cases: basically because of the essence operator, we are forced to prove both requirements of a morphism mutually:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Lemma} \coqdefRef{NFO.Morphism.IN respects EQ}{IN\_respects\_EQ}{\coqdoclemma{IN\_respects\_EQ}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{s'} \coqdocvar{t}, \coqdoceol
  \coqdocindent{1.00em}
  \coqdocvariable{s} \EQX\coqdocvariable{s'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}
  \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{z} \INX \coqdocvariable{x} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}}  \coqdocvariable{z} \INX \coqdocvariable{y}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}
  \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}} \coqdocvariable{x} \INX \coqdocvariable{z} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}}  \coqdocvariable{y} \INX  \coqdocvariable{z}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  By induction on \var t and then by well-founded induction on the order $<_2$.
\end{proof}

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Add} \coqdockw{Morphism} \coqref{NFO.In.IN}{\coqdocdefinition{IN}} \coqdockw{with} \coqdockw{signature} \coqref{NFO.Eq.EQ}{\coqdocdefinition{EQ}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{$\Rightarrow$}} \coqref{NFO.Eq.EQ}{\coqdocdefinition{EQ}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{$\Rightarrow$}} \coqexternalref{iff}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{iff}} \coqdockw{as} \coqdocdefinition{IN\_mor}.\coqdoceol
\end{coqdoccode}
% \begin{proof}
%   TODO ARGH DIFFICILE!

% \end{proof}

\subsection{Set Operators}
% \TODO{universo gia' definito in ex?, and correctness is trivial.}
% \TODO{Dire che precedenti (a parte unione) sono facili.}
Let us start from the complement:
\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Definition} \coqdefRef{NFO.Sets.compl}{compl}{\coqdocdefinition{compl}} \coqdocvar{s} := \coqdockw{match} \coqdocvariable{s} \coqdockw{with}\coqdoceol
  \coqdocindent{1.00em}
  \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{e} \ensuremath{\Rightarrow} \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} (\coqref{NFO.BoolExpr.Not}{\coqdocconstructor{Not}} \coqdocvar{e})\coqdoceol
  \coqdocnoindent
  \coqdockw{end}.\coqdoceol
  \coqdocemptyline
  \coqdocnoindent
  \coqdockw{Theorem} \coqdefRef{NFO.Sets.compl ok}{compl\_ok}{\coqdoclemma{compl\_ok}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{t},\coqdoceol
  \coqdocindent{1.00em}
   \coqdocvariable{s} \INX (\coqref{NFO.Sets.compl}{\coqdocdefinition{compl}} \coqdocvariable{t}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{s} \INX \coqdocvariable{t} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  Let \coqdocvar{t} = \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{e}.
  After basic simplifications, the statement becomes:
  \begin{center}
    \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{t}, \coqdocvar{s} \AIN \coqdocvar{f} \XOR $\neg$ (\coqdocvar{s} \BIN \coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvar{g} \coqdocvar{e}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} $\neg$ (\coqdocvar{s} \AIN \coqdocvar{f}\XOR \coqdocvar{s} \BIN \coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvar{g} \coqdocvar{e})
  \end{center}
  which holds classically because negation commutes with xor.
\end{proof}

Let's proceed with the singleton:

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Definition} \coqdefRef{NFO.Sets.sin}{sin}{\coqdocdefinition{sin}} \coqdocvar{s} := \coqdoceol
  \coqdocindent{1.00em}
  \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqexternalref{unit}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{unit}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} (\coqdockw{fun} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvariable{s}) (\coqexternalref{False rect}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{False\_rect}} \coqdocvar{\_}) \coqref{NFO.BoolExpr.Bot}{\coqdocconstructor{Bot}}.\coqdoceol
  \coqdocemptyline
  \coqdocnoindent
  \coqdockw{Theorem} \coqdefRef{NFO.Sets.sin ok}{sin\_ok}{\coqdoclemma{sin\_ok}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{t}, \coqdocvariable{s} \INX (\coqref{NFO.Sets.sin}{\coqdocdefinition{sin}} \coqdocvariable{t}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \EQX \coqdocvariable{s}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  After basic simplifications, the statement becomes
    \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{t}, \coqdocvar{t} \EQX \coqdocvar{s} \XOR \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvar{t} \EQX \coqdocvar{s},
  which holds classically because \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} is the identity element for xor.
\end{proof}

Then the essence (which we call ``cosin'' as a pun on ``sin''):

\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Definition} \coqdefRef{NFO.Sets.cosin}{cosin}{\coqdocdefinition{cosin}} \coqdocvar{s} := \coqdoceol
  \coqdocindent{1.00em}\coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} \coqexternalref{unit}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{unit}} (\coqexternalref{False rect}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{False\_rect}} \coqdocvar{\_}) (\coqdockw{fun} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvariable{s}) (\coqref{NFO.BoolExpr.Atom}{\coqdocconstructor{Atom}} \coqexternalref{tt}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{tt}}).\coqdoceol
  \coqdocemptyline
  \coqdocnoindent
  \coqdockw{Theorem} \coqdefRef{NFO.Sets.cosin ok}{cosin\_ok}{\coqdoclemma{cosin\_ok}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{t}, \coqdocvariable{s} \INX (\coqref{NFO.Sets.cosin}{\coqdocdefinition{cosin}} \coqdocvariable{t}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \INX \coqdocvariable{s}.\coqdoceol
\end{coqdoccode}
\begin{proof}
  After basic simplifications, the statement becomes \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{t}, \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} \XOR (\coqdocvariable{t} \BIN \coqdocvariable{s}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} (\coqdocvariable{t} \BIN \coqdocvariable{s}), which holds classically because \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} is the identity element for xor.
\end{proof}


\paragraph{Set union.} Defining the union is quite involved. 
We need to use the following informally identity over booleans: $(a_1 \veebar b_1) \vee (a_2 \veebar b_2) \approx a \veebar (b_1 \lor b_2)$ where 
\[ \begin{array}{rl}
  a := & \hspace{0.8em}(a_1 \land (b_2 \to b_1) \land ( b_1 \to ( a_1 \leftrightarrow b_2 ) )) \\
         & \lor ~(a_2 \land (b_1 \to b_2) \land ( b_2 \to ( a_2 \leftrightarrow b_1 ) )) \\
\end{array} \]

% (* (a -> b) /\ (b -> (c <-> a)) *)


The union of NFO sets is defined as follows:

\begin{itemize}
\item  The resulting \B-part is simply the union of the input \B-parts.

\item  The resulting \A-part is a more complex combination of the input \A-parts and \B-parts.
      % TODO:

\end{itemize}


%  TODO: clean up and explain
 
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdefRef{NFO.Union.half}{half}{\coqdocdefinition{half}} \{\coqdocvar{X}\} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}) \coqdocvar{e} \coqdocvar{e'} \coqdocvar{s} := \coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{s} \BIN \coqdocvariable{e'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \BIN \coqdocvariable{e}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{s} \BIN \coqdocvariable{e} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}  \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{s} \AIN \coqdocvariable{f} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s} \BIN \coqdocvariable{e'}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdefRef{NFO.Union.half respects}{half\_respects}{\coqdoclemma{half\_respects}} \{\coqdocvar{X}\} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}) \coqdocvar{e} \coqdocvar{e'}:\coqdoceol
\coqdocindent{1.00em}
\coqref{Internal.FunExt.respects}{\coqdocdefinition{respects}} \coqref{NFO.Eq.EQ}{\coqdocdefinition{EQ}} (\coqref{NFO.Union.half}{\coqdocdefinition{half}} \coqdocvariable{f} \coqdocvariable{e} \coqdocvariable{e'}).\coqdoceol
\end{coqdoccode}
\begin{proof}
  It follows directly from \coqref{NFO.Union.half}{\coqdocdefinition{half}} being defined in terms of \coqdocdefinition{AIN} and \coqdocdefinition{BIN}, which are \coqdocdefinition{EQ}-morphisms.
\end{proof}

\coqdocdefinition{restrictC} \var f \var P restricts the domain of a function \var f according to a predicate \var P that restricts the codomain:

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdefRef{NFO.Union.restrictC}{restrictC}{\coqdocdefinition{restrictC}} \{\coqdocvar{X} \coqdocvar{Y}\} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}) (\coqdocvar{P}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop})\coqdoceol
\coqdocindent{1.00em}
: \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{x}\coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvariable{X} \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\&}} \coqdocvariable{P} (\coqdocvariable{f} \coqdocvariable{x}) \coqexternalref{::type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}\coqdoceol
\coqdocindent{1.00em}
:= \coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvariable{f} (\coqexternalref{projT1}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvariable{x}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdefRef{NFO.Union.cup}{cup}{\coqdocdefinition{cup}} \coqdocvar{s} \coqdocvar{t} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{s}, \coqdocvariable{t} \coqdockw{with} \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{e}, \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X'} \coqdocvar{Y'} \coqdocvar{f'} \coqdocvar{g'} \coqdocvar{e'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{\_} \coqdocvar{\_}\coqdoceol
\coqdocindent{3.00em}
(   \coqref{NFO.Union.restrictC}{\coqdocdefinition{restrictC}} \coqdocvar{f}  (\coqref{NFO.Union.half}{\coqdocdefinition{half}} \coqdocvar{f'} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvar{g}  \coqdocvar{e} ) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvar{g'} \coqdocvar{e'}))\coqdoceol
\coqdocindent{3.50em}
\coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqref{NFO.Union.restrictC}{\coqdocdefinition{restrictC}} \coqdocvar{f'} (\coqref{NFO.Union.half}{\coqdocdefinition{half}} \coqdocvar{f}  (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvar{g'} \coqdocvar{e'}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqdocvar{g}  \coqdocvar{e} )))\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{g} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvar{g'})\coqdoceol
\coqdocindent{3.00em}
(\coqref{NFO.BoolExpr.Or}{\coqdocconstructor{Or}} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{e}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvar{e'}))\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdefRef{NFO.Union.cup ok}{cup\_ok}{\coqdoclemma{cup\_ok}} \coqdocvar{s} \coqdocvar{s'} \coqdocvar{t}: \coqdocvariable{t} \INX (\coqref{NFO.Union.cup}{\coqdocdefinition{cup}} \coqdocvariable{s} \coqdocvariable{s'}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \INX \coqdocvariable{s} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{t} \INX \coqdocvariable{s'}.\coqdoceol
\end{coqdoccode}
% \begin{proof}
%   \TODO{}
% \end{proof}

\paragraph{Symmetric difference}

We resort to informal boolean reasoning: $(a_1 \veebar b_1) \veebar (a_2 \veebar b_2) \approx (a_1 \veebar a_2) \veebar (b_1 \veebar b_2)$ since xor is associative and commutative.

\begin{coqdoccode}
    \coqdocemptyline
    \coqdocnoindent
    \coqdockw{Definition} \coqdefRef{NFO.Sets.AXor}{Axor}{\coqdocdefinition{Axor}} \{\coqdocvar{X} \coqdocvar{Y}\} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}) (\coqdocvar{g}: \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}})\coqdoceol
    \coqdocindent{1.00em}
    : \coqexternalref{::type scope:'x7B' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\{}}\coqdocvar{x} \coqexternalref{::type scope:'x7B' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\&}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{y}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} (\coqdocvariable{g} \coqdocvariable{y}) \EQX (\coqdocvariable{f} \coqdocvariable{x})\coqexternalref{::type scope:'x7B' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\}}} \coqdoceol
    \coqdocindent{2.00em}
    \coqexternalref{sum}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{+}} \coqexternalref{::type scope:'x7B' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\{}}\coqdocvar{y} \coqexternalref{::type scope:'x7B' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\&}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} (\coqdocvariable{f} \coqdocvariable{x}) \EQX (\coqdocvariable{g} \coqdocvariable{y})\coqexternalref{::type scope:'x7B' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocnotation{\}}} \coqdoceol
    \coqdocindent{3.00em}
    \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}\coqdoceol
    \coqdocindent{1.00em}
    := \coqdockw{fun} \coqdocvar{s} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{s} \coqdockw{with}\coqdoceol
    \coqdocindent{3.00em}
    \ensuremath{|} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvariable{f} (\coqexternalref{projT1}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{x})\coqdoceol
    \coqdocindent{3.00em}
    \ensuremath{|} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdocvariable{g} (\coqexternalref{projT1}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{y}) \coqdoceol
    \coqdocindent{2.00em}
    \coqdockw{end}.\coqdoceol
    \coqdocnoindent
    \coqdockw{Infix} \coqdef{NFO.Sets.:::x 'x5EAx5E' x}{"}{"}\AXOR" := \coqref{NFO.Sets.AXor}{\coqdocdefinition{Axor}} (\coqdoctac{at} \coqdockw{level} 50).\coqdoceol
    \coqdocemptyline
\end{coqdoccode}

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Definition} \coqdefRef{NFO.Sets.bexpr xor}{bexpr\_xor}{\coqdocdefinition{bexpr\_xor}} \{\coqdocvar{Y}\} (\coqdocvar{e} \coqdocvar{e'}: @\coqref{NFO.BoolExpr.BExpr}{\coqdocinductive{BExpr}} \coqdocvariable{Y}) :=\coqdoceol
\coqdocindent{1.00em}
\coqref{NFO.BoolExpr.Or}{\coqdocconstructor{Or}} (\coqref{NFO.BoolExpr.Not}{\coqdocconstructor{Not}} (\coqref{NFO.BoolExpr.Or}{\coqdocconstructor{Or}} \coqdocvariable{e} (\coqref{NFO.BoolExpr.Not}{\coqdocconstructor{Not}} \coqdocvariable{e'}))) (\coqref{NFO.BoolExpr.Not}{\coqdocconstructor{Not}} (\coqref{NFO.BoolExpr.Or}{\coqdocconstructor{Or}} (\coqref{NFO.BoolExpr.Not}{\coqdocconstructor{Not}} \coqdocvariable{e}) \coqdocvariable{e'})).\coqdoceol
\coqdocemptyline

\coqdocnoindent
\coqdockw{Definition} \coqdefRef{NFO.Sets.QXor}{XOR}{\coqdocdefinition{XOR}} \coqdocvar{s} \coqdocvar{s'} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{s}, \coqdocvariable{s'} \coqdockw{with} \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{e}, \coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{X'} \coqdocvar{Y'} \coqdocvar{f'} \coqdocvar{g'} \coqdocvar{e'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqref{NFO.Model.S}{\coqdocconstructor{S}} \coqdocvar{\_} \coqdocvar{\_}\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{f} \AXOR \coqdocvar{f'})\coqdoceol
\coqdocindent{4.00em}
(\coqdocvar{g} \coqref{Internal.Misc.:::x 'xE2xA8x81' x}{\coqdocnotation{⨁}} \coqdocvar{g'}) (\coqref{NFO.Sets.bexpr xor}{\coqdocdefinition{bexpr\_xor}} (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inl}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{e}) (\coqref{NFO.BoolExpr.map}{\coqdocdefinition{map}} \coqexternalref{inr}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvar{e'}))\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Infix} \coqdef{NFO.Sets.:::x 'x5Ex5Ex5E' x}{"}{"}\SXOR" := \coqref{NFO.Sets.QXor}{\coqdocdefinition{XOR}} (\coqdoctac{at} \coqdockw{level} 50).\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\begin{coqdoccode}
  \coqdocnoindent
\coqdockw{Lemma} \coqdef{NFO.Sets.AXor ok}{Axor\_ok}{\coqdoclemma{Axor\_ok}} \{\coqdocvar{X} \coqdocvar{X'}\} \{\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}\} \{\coqdocvar{f'}: \coqdocvariable{X'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{NFO.Model.SET}{\coqdocinductive{SET}}\} \{\coqdocvar{x}\}:\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} \AIN (\coqdocvariable{f} \AXOR \coqdocvariable{f'}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{x} \AIN \coqdocvariable{f} \coqref{NFO.Xor.:::x 'xE2x8AxBB' x}{\coqdocnotation{⊻}} \coqdocvariable{x} \AIN \coqdocvariable{f'}.\coqdoceol
\end{coqdoccode}
\begin{coqdoccode}
  \coqdocnoindent
  \coqdockw{Theorem} \coqdefRef{NFO.Sets.xor ok}{xor\_ok}{\coqdoclemma{XOR\_ok}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{s'} \coqdocvar{t},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{t} \INX (\coqdocvariable{s} \SXOR \coqdocvariable{s'}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{t} \INX \coqdocvariable{s} \coqref{NFO.Xor.:::x 'xE2x8AxBB' x}{\coqdocnotation{⊻}} \coqdocvariable{t} \INX \coqdocvariable{s'}.\coqdoceol
\end{coqdoccode}

% \TODO{define xor of sets! needed in next subsection.}

\subsection{Extensionality}
\input{nfo_ext.tex}
